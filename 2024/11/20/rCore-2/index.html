<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wdlin233.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="ch4 分页机制与地址空间这个视频作了一个不错的概述: 【操作系统】内存管理——地址空间. 用satpCSR的MODE字段来开启MMU.   物理地址&#x2F;虚拟地址&#x2F;物理页面&#x2F;物理页帧单个页面的大小设置为 4KiB(PAGE_SIZE) ，每个虚拟页面和物理页帧都按 4 KB 对齐。 4KiB 需要用 12 位字节地址来表示，构成低 12 位即 页内偏移 (Page Of">
<meta property="og:type" content="article">
<meta property="og:title" content="rCore-2">
<meta property="og:url" content="https://wdlin233.github.io/2024/11/20/rCore-2/index.html">
<meta property="og:site_name" content="wdlin&#39;s Blog">
<meta property="og:description" content="ch4 分页机制与地址空间这个视频作了一个不错的概述: 【操作系统】内存管理——地址空间. 用satpCSR的MODE字段来开启MMU.   物理地址&#x2F;虚拟地址&#x2F;物理页面&#x2F;物理页帧单个页面的大小设置为 4KiB(PAGE_SIZE) ，每个虚拟页面和物理页帧都按 4 KB 对齐。 4KiB 需要用 12 位字节地址来表示，构成低 12 位即 页内偏移 (Page Of">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://learningos.cn/rCore-Camp-Guide-2024A/_images/satp.png">
<meta property="og:image" content="https://learningos.cn/rCore-Camp-Guide-2024A/_images/sv39-va-pa.png">
<meta property="og:image" content="https://learningos.cn/rCore-Camp-Guide-2024A/_images/sv39-pte.png">
<meta property="og:image" content="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/kernel-as-high.png">
<meta property="og:image" content="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/kernel-as-low.png">
<meta property="og:image" content="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/app-as-full.png">
<meta property="article:published_time" content="2024-11-20T13:48:17.000Z">
<meta property="article:modified_time" content="2024-11-29T09:41:10.231Z">
<meta property="article:author" content="wdlin233">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://learningos.cn/rCore-Camp-Guide-2024A/_images/satp.png">


<link rel="canonical" href="https://wdlin233.github.io/2024/11/20/rCore-2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://wdlin233.github.io/2024/11/20/rCore-2/","path":"2024/11/20/rCore-2/","title":"rCore-2"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>rCore-2 | wdlin's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">wdlin's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">希望本是无所谓有，无所谓无的</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#ch4-%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.</span> <span class="nav-text">ch4 分页机制与地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80-%E7%89%A9%E7%90%86%E9%A1%B5%E9%9D%A2-%E7%89%A9%E7%90%86%E9%A1%B5%E5%B8%A7"><span class="nav-number">1.1.</span> <span class="nav-text">物理地址&#x2F;虚拟地址&#x2F;物理页面&#x2F;物理页帧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9PTE"><span class="nav-number">1.2.</span> <span class="nav-text">页表项PTE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E9%A1%B5%E5%B8%A7%E4%B8%8EFrameAllocator"><span class="nav-number">1.3.</span> <span class="nav-text">物理页帧与FrameAllocator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%B1%82%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text">多层页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="nav-number">1.5.</span> <span class="nav-text">虚实地址映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E6%AE%B5%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.6.</span> <span class="nav-text">逻辑段与地址空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.7.</span> <span class="nav-text">内核地址空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.8.</span> <span class="nav-text">应用地址空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.9.</span> <span class="nav-text">内核初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E6%9D%BFTrampoline"><span class="nav-number">1.10.</span> <span class="nav-text">跳板Trampoline</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wdlin233"
      src="/images/Mashiro.jpg">
  <p class="site-author-name" itemprop="name">wdlin233</p>
  <div class="site-description" itemprop="description">Man's world is mutable, seas become mulberry fields.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wdlin233" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wdlin233" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wdlin233.github.io/2024/11/20/rCore-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Mashiro.jpg">
      <meta itemprop="name" content="wdlin233">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wdlin's Blog">
      <meta itemprop="description" content="Man's world is mutable, seas become mulberry fields.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="rCore-2 | wdlin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          rCore-2
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-20 21:48:17" itemprop="dateCreated datePublished" datetime="2024-11-20T21:48:17+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-29 17:41:10" itemprop="dateModified" datetime="2024-11-29T17:41:10+08:00">2024-11-29</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>34 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="ch4-分页机制与地址空间"><a href="#ch4-分页机制与地址空间" class="headerlink" title="ch4 分页机制与地址空间"></a>ch4 分页机制与地址空间</h3><p>这个视频作了一个不错的概述: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1oi4y1T7RP/?share_source=copy_web&vd_source=7065d846d368bb90906c142c279a2832">【操作系统】内存管理——地址空间</a>.</p>
<p>用<code>satp</code>CSR的MODE字段来开启MMU.</p>
<img src="https://learningos.cn/rCore-Camp-Guide-2024A/_images/satp.png" alt="satp CSR" style="zoom:67%;" />

<h4 id="物理地址-虚拟地址-物理页面-物理页帧"><a href="#物理地址-虚拟地址-物理页面-物理页帧" class="headerlink" title="物理地址&#x2F;虚拟地址&#x2F;物理页面&#x2F;物理页帧"></a>物理地址&#x2F;虚拟地址&#x2F;物理页面&#x2F;物理页帧</h4><p>单个页面的大小设置为 4KiB(<code>PAGE_SIZE</code>) ，每个虚拟页面和物理页帧都按 4 KB 对齐。 4KiB 需要用 12 位字节地址来表示，构成低 12 位即 <strong>页内偏移</strong> (Page Offset) 。</p>
<p>虚拟地址的高 27 位，即 [38:12] 为它的虚拟页号 VPN； 物理地址的高 44 位，即 [55:12] 为它的物理页号 PPN。页号可以用来定位一个虚拟&#x2F;物理地址属于哪一个虚拟页面&#x2F;<strong>物理页帧</strong>。</p>
<img src="https://learningos.cn/rCore-Camp-Guide-2024A/_images/sv39-va-pa.png" alt="Address" style="zoom:67%;" />

<p>于是对地址类型，有取页内偏移量的操作<code>page_offset</code>，用二进制与运算实现；取页码<code>PPN</code>用二进制除法实现取<code>PhysAddr</code>的高位：</p>
<span id="more"></span>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/address.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PhysAddr</span> &#123;</span><br><span class="line">    <span class="comment">/// Get the (floor) physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">floor</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123;</span><br><span class="line">        <span class="title function_ invoke__">PhysPageNum</span>(<span class="keyword">self</span>.<span class="number">0</span> / PAGE_SIZE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Get the page offset of physical address</span></span><br><span class="line">    <span class="comment">//  pub const PAGE_SIZE: usize = 4096 (0x1000) = ..1_0000_0000_0000</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">page_offset</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span> &amp; (PAGE_SIZE - <span class="number">1</span>) <span class="comment">// 1111_1111_1111</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PhysAddr -&gt; PhysPageNum</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;PhysAddr&gt; <span class="keyword">for</span> <span class="title class_">PhysPageNum</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(v: PhysAddr) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">page_offset</span>(), <span class="number">0</span>);</span><br><span class="line">        v.<span class="title function_ invoke__">floor</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PhysPageNum -&gt; PhysAddr</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;PhysPageNum&gt; <span class="keyword">for</span> <span class="title class_">PhysAddr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(v: PhysPageNum) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Self</span>(v.<span class="number">0</span> &lt;&lt; PAGE_SIZE_BITS)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>地址转换是以页为单位进行的，<strong>转换前后地址页内偏移部分不变</strong>。MMU 只是从虚拟地址中取出 27 位虚拟页号， 在页表中查到其对应的物理页号，如果找到，就将得到的 44 位的物理页号与 12 位页内偏移拼接到一起，形成 56 位物理地址。</p>
<h4 id="页表项PTE"><a href="#页表项PTE" class="headerlink" title="页表项PTE"></a>页表项PTE</h4><p>在页表中以虚拟页号作为索引不仅能够查到物理页号，还能查到一组保护位，它控制了应用对地址空间每个虚拟页面的访问权限。但实际上还有更多的标志位，物理页号和全部的标志位以某种固定的格式保存在一个结构体中，它被称为 <strong>页表项</strong> (PTE, Page Table Entry) ，是利用虚拟页号在页表中查到的结果。低位8位标志位<code>PTEFlags</code>具体可见<a target="_blank" rel="noopener" href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html#id5">SV39 多级页表的硬件机制 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</a>.</p>
<img src="https://learningos.cn/rCore-Camp-Guide-2024A/_images/sv39-pte.png" alt="PTE" style="zoom:67%;" />

<p><code>ppn</code>函数将<code>PTE</code>的PPN部分与0xFFFFFFFFFFF（十六进制形式的 44 个 1）取与，将得到的结果用<code>into()</code>进行转换位<code>PhysPageNum</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"><span class="comment">/// page table entry structure</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PageTableEntry</span> &#123;</span><br><span class="line">    <span class="comment">/// bits of page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> bits: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTableEntry</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(ppn: PhysPageNum, flags: PTEFlags) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        PageTableEntry &#123;</span><br><span class="line">            bits: ppn.<span class="number">0</span> &lt;&lt; <span class="number">10</span> | flags.bits <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Get the physical page number from the page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">ppn</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123;</span><br><span class="line">        (<span class="keyword">self</span>.bits &gt;&gt; <span class="number">10</span> &amp; ((<span class="number">1usize</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>)).<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Get the flags from the page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">flags</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PTEFlags &#123;</span><br><span class="line">        PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.bits <span class="keyword">as</span> <span class="type">u8</span>).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="物理页帧与FrameAllocator"><a href="#物理页帧与FrameAllocator" class="headerlink" title="物理页帧与FrameAllocator"></a>物理页帧与FrameAllocator</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/config.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> MEMORY_END: <span class="type">usize</span> = <span class="number">0x80800000</span>;</span><br></pre></td></tr></table></figure>

<p>我们硬编码整块物理内存的终止物理地址为 <code>0x80800000</code> 。 而物理内存的起始物理地址为 <code>0x80000000</code> ， 意味着我们将可用内存大小设置为 8MiB ，当然也可以设置的更大一点。</p>
<blockquote>
<p>这里应当与ekernel的实现有关系，直接运算得到的结果并不是8MiB. 待补充…</p>
</blockquote>
<p>实现物理页帧管理器，以物理页号为单位进行物理页帧的分配和回收。物理页号区间 [ <code>current</code> , <code>end</code> ) 此前均 <em>从未</em> 被分配出去过，而向量 <code>recycled</code> 以后入先出的方式保存了被回收的物理页号（内核堆）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>, <span class="comment">//空闲内存空间起始物理页号</span></span><br><span class="line">    end: <span class="type">usize</span>,</span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, l: PhysPageNum, r: PhysPageNum) &#123;</span><br><span class="line">        <span class="keyword">self</span>.current = l.<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.end = r.<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// trace!(&quot;last &#123;&#125; Physical Frames.&quot;, self.end - self.current);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将Trait<code>FrameAllocator</code>作用给<code>StackFrameAllocator</code>. 分配 <code>alloc</code> 的时候，首先会检查栈 <code>recycled</code> 内有没有之前回收的物理页号，如果有的话直接弹出栈顶并返回；否则的话我们只能从之前从未分配过的物理页号区间 [ <code>current</code> , <code>end</code> ) 上进行分配；回收的时候检测回收页面合法性</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FrameAllocator</span> <span class="keyword">for</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            current: <span class="number">0</span>,</span><br><span class="line">            end: <span class="number">0</span>,</span><br><span class="line">            recycled: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">alloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysPageNum&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(ppn) = <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(ppn.<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">self</span>.current == <span class="keyword">self</span>.end &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>((<span class="keyword">self</span>.current - <span class="number">1</span>).<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dealloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ppn</span> = ppn.<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// validity check</span></span><br><span class="line">        <span class="keyword">if</span> ppn &gt;= <span class="keyword">self</span>.current || <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">any</span>(|&amp;v| v == ppn) &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Frame ppn=&#123;:#x&#125; has not been allocated!&quot;</span>, ppn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// recycle</span></span><br><span class="line">        <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">push</span>(ppn);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// another version of validity check</span></span><br><span class="line">        <span class="comment">// if ppn &gt;= self.current || self.recycled</span></span><br><span class="line">        <span class="comment">//     .iter()</span></span><br><span class="line">        <span class="comment">//     .find(|&amp;v| &#123;*v == ppn&#125;)</span></span><br><span class="line">        <span class="comment">//     .is_some() &#123;</span></span><br><span class="line">        <span class="comment">//     panic!(&quot;Frame ppn=&#123;:#x&#125; has not been allocated!&quot;, ppn);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>StackFrameAllocator</code>进行全局实例化与初始化.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FrameAllocatorImpl</span> = StackFrameAllocator;</span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="comment">/// frame allocator instance through lazy_static!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> FRAME_ALLOCATOR: UPSafeCell&lt;FrameAllocatorImpl&gt; =</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(FrameAllocatorImpl::<span class="title function_ invoke__">new</span>()) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// initiate the frame allocator using `ekernel` and `MEMORY_END`</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_frame_allocator</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ekernel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    FRAME_ALLOCATOR.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">init</span>(</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(ekernel <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">ceil</span>(),</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(MEMORY_END).<span class="title function_ invoke__">floor</span>(),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>FrameTracker</code>的构建如下，<code>frame_alloc</code> 的返回值类型并不是 物理页号 <code>PhysPageNum</code> ，而是将其进一步包装为一个 <code>FrameTracker</code>. 将一个物理页帧的生命周期绑定到一个 <code>FrameTracker</code> 变量上，当一个 <code>FrameTracker</code> 被创建的时候，我们需要从 <code>FRAME_ALLOCATOR</code> 中分配一个物理页帧：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="comment">/// physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new FrameTracker</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(ppn: PhysPageNum) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// page cleaning</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">bytes_array</span> = ppn.<span class="title function_ invoke__">get_bytes_array</span>();</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> bytes_array &#123;</span><br><span class="line">            *i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ppn &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，物理页帧<code>FrameTracker</code>仅由<code>ppn:PhysPageNum</code>所组成，而不包含偏移量。因为，<strong>每个物理页帧对应一连续的物理地址范围</strong>。要从物理页帧和页内偏移计算出具体物理地址，有公式：</p>
<p>PhysAddr &#x3D; FrameNumber * PageSize + Offset</p>
<p>当一个 <code>FrameTracker</code> 生命周期结束被编译器回收的时候，它的 <code>drop</code> 方法会<strong>自动</strong>被编译器调用. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">frame_dealloc</span>(<span class="keyword">self</span>.ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Drop Trait有诸多便捷的特性，详细可见<a target="_blank" rel="noopener" href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/4sv39-implementation-2.html#id4">管理 SV39 多级页表 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</a></p>
</blockquote>
<h4 id="多层页表"><a href="#多层页表" class="headerlink" title="多层页表"></a>多层页表</h4><p>每个应用的地址空间都对映一个不同的多级页表，这也就意味这不同页表的起始地址（即页表根节点的地址）是不一样的。因此 <code>PageTable</code> 要保存它根节点的物理页号 <code>root_ppn</code> 作为<strong>页表唯一的区分标志</strong>。此外， 向量 <code>frames</code> 以 <code>FrameTracker</code> 的形式保存了页表所有的节点（包括根节点）所在的<strong>物理页帧</strong>。</p>
<p><code>frame</code>是一个<code>FrameTracker</code>类型的变量，其具有唯一的结构体元素<code>ppn</code>(PhysPageNum).</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    root_ppn: PhysPageNum,</span><br><span class="line">    frames: <span class="type">Vec</span>&lt;FrameTracker&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new page table</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        PageTable &#123;</span><br><span class="line">            root_ppn: frame.ppn,</span><br><span class="line">            frames: <span class="built_in">vec!</span>[frame],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了接续接下来的内容，此处我们需要理解SV39的页表机制。每个节点都被保存在一个物理页帧中。在 SV39 中，页表是分层结构，每一层的页表被称为一个<strong>节点</strong>。这些节点的作用是存储虚拟地址到物理地址的映射关系，或者指向下一层的页表。一个节点包含多个页表项（Page Table Entries, PTEs），每个页表项要么存储物理页帧地址，要么存储指向下一层页表的物理地址。<strong>每个节点会占据一个物理页帧</strong>。</p>
<p>在 SV39 中：</p>
<ul>
<li>一个页表条目（PTE）是 8 字节。</li>
<li>一个物理页帧大小是 4 KB。</li>
</ul>
<p>因此，一个物理页帧可以容纳： 4KB &#x2F; 8B &#x3D; 512 即 <strong>512 个页表条目</strong>。</p>
<p>通过这种设计，每个页表节点恰好是一个物理页帧，这简化了硬件设计：</p>
<ul>
<li>硬件可以直接通过 PPN（物理页帧号）定位到对应的页表节点。</li>
<li>页表查找只需通过偏移（Offset）找到具体的 PTE，而无需动态分配额外内存</li>
</ul>
<p>其实可以理解为，页表中的每一个基本单位都是一个物理页帧，此称为节点。</p>
<p>由此我们可以开始构建映射：为了 MMU 能够通过地址转换正确找到应用地址空间中的数据实际被内核放在内存中 位置，操作系统需要动态维护一个<strong>虚拟页号</strong>到<strong>页表项</strong>的映射，支持插入&#x2F;删除键值对，其方法签名如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags);</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个节点都被保存在一个物理页帧中，在多级页表的架构中，一个节点对应的物理页号作为指针指向该节点。一旦我们知道了指向某一个节点的物理页号，我们就需要能够修改这个节点的内容。在操作某个多级页表或是管理物理页帧的时候，我们要能够自由的读写一个给定的物理页号对应的物理页帧上的数据。</p>
<p>此处我们采用由<code>vpn</code>到<code>ppn</code>的<strong>恒等映射</strong>，此处还有其他映射方式如页表自映射等，可见<a target="_blank" rel="noopener" href="https://os.phil-opp.com/paging-implementation/#accessing-page-tables">BlogOS中的相关介绍</a>.</p>
<h4 id="虚实地址映射"><a href="#虚实地址映射" class="headerlink" title="虚实地址映射"></a>虚实地址映射</h4><p>应用和内核的地址空间是隔离的。而直接访问物理页帧的操作只会在内核中进行， 应用无法看到物理页帧管理器和多级页表等内核数据结构。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/address.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PhysPageNum</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_pte_array</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> [PageTableEntry] &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pa</span>: PhysAddr = <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">into</span>();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(pa.<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">mut</span> PageTableEntry, <span class="number">512</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_bytes_array</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> [<span class="type">u8</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pa</span>: PhysAddr = <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">into</span>();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(pa.<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, <span class="number">4096</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>&lt;T&gt;(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pa</span>: PhysAddr = <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">into</span>();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            (pa.<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">mut</span> T).<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的512是因为一个页占4KB，每个页表项占 8 字节，4096 &#x2F; 8 总共 512 项，表示一个页表节点中的页表项数量。而4096就表示一个页的大小4 KB，即一个物理页帧的字节总数。</p>
<p>我们构造<strong>可变引用</strong>来直接访问一个物理页号 <code>PhysPageNum</code> 对应的物理页帧，不同的引用类型对应于物理页帧上的一种不同的 内存布局。如 <code>get_pte_array</code> 返回的是一个页表项定长数组的可变引用，可以用来修改多级页表中的一个节点；而 <code>get_bytes_array</code> 返回的是一个字节数组的可变引用，可以以字节为粒度对物理页帧上的数据进行访问。</p>
<p>在实现方面，先把物理页号转为物理地址 <code>PhysAddr</code> ，再转成 usize 形式的物理地址。接着，将它转为裸指针来访问物理地址指向的物理内存。在分页机制开启之后，虽然裸指针被视为一个虚拟地址， 但虚拟地址会映射到一个相同的物理地址，也成立。</p>
<blockquote>
<p>注意，返回值类型上附加静态生命周期泛型 <code>&#39;static</code> 以绕过 Rust 编译器的借用检查。实质上可以将返回的类型看作裸指针，因为它也只是标识数据存放的位置以及类型。但与裸指针不同的是，无需通过 <code>unsafe</code> 的解引用，而可以作为正常的可变引用一样直接访问。</p>
</blockquote>
<p><code>map</code>和<code>unmap</code>都依赖于在多级页表中找到一个虚拟地址对应的页表项的过程，找到之后，只要修改页表项的内容即可完成键值对的插入和删除。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/address.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">VirtPageNum</span> &#123;</span><br><span class="line">    <span class="comment">/// Get the indexes of the page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">indexes</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> [<span class="type">usize</span>; <span class="number">3</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vpn</span> = <span class="keyword">self</span>.<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">idx</span> = [<span class="number">0usize</span>; <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..<span class="number">3</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">            idx[i] = vpn &amp; <span class="number">511</span>;</span><br><span class="line">            vpn &gt;&gt;= <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">find_pte_create</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">        <span class="comment">/// Find PageTableEntry by VirtPageNum, create a frame for a 4KB page table if not exist</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[idxs[i]];</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">                result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);</span><br><span class="line">                <span class="keyword">self</span>.frames.<span class="title function_ invoke__">push</span>(frame);</span><br><span class="line">            &#125;</span><br><span class="line">            ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，  <code>indexes</code> 用于取出虚拟页号<code>vpn</code>的三级页索引，并按照从高到低的顺序返回。<code>find_pte_create</code>用于在<code>vpn</code>中三级页索引的指定下，逐级遍历各层<code>pte</code>。如果在遍历的过程中发现有节点尚未创建则会新建一个节点。</p>
<p>为了 <strong>MMU</strong> 能够通过地址转换正确找到应用地址空间中的数据实际被内核放在内存中 位置，操作系统需要动态维护一个<strong>虚拟页号</strong>到<strong>页表项</strong>的映射. 由此即可实现<code>map</code>与<code>unmap</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="comment">/// set the map between virtual page number and physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte_create</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(!pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is mapped before mapping&quot;</span>, vpn);</span><br><span class="line">        *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(ppn, flags | PTEFlags::V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// remove the map between virtual page number and physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte_create</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is invalid before unmapping&quot;</span>, vpn);</span><br><span class="line">        *pte = PageTableEntry::<span class="title function_ invoke__">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>vpn</code>对应的<code>pte</code>不可用，说明此时可以使用<code>map</code>进行映射.</p>
<blockquote>
<p>目前的实现方式并不打算对物理页帧耗尽的情形做任何处理而是直接 <code>panic</code> 退出。因此在前面的代码中能够看到 很多 <code>unwrap</code> ，这种使用方式并不为 Rust 所推荐，只是由于简单起见暂且这样做。</p>
</blockquote>
<p>我们还需要 <code>PageTable</code> 提供一种不经过 MMU 而是手动查页表的方法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="comment">/// Temporarily used to get arguments from user space.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_token</span>(satp: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            root_ppn: PhysPageNum::<span class="title function_ invoke__">from</span>(satp &amp; ((<span class="number">1usize</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>)),</span><br><span class="line">            frames: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">find_pte</span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;PageTableEntry&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">pte</span> = &amp;ppn.<span class="title function_ invoke__">get_pte_array</span>()[idxs[i]];</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">                result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">translate</span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PageTableEntry&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte</span>(vpn)</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|pte| &#123;pte.<span class="title function_ invoke__">clone</span>()&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>translate</code> 通过调用 <code>find_pte</code> 来实现，如果能够找到页表项，那么它会将页表项拷贝一份并返回，否则就返回一个 <code>None</code>. 实现的是虚拟页号向PTE的转换.</p>
<h4 id="逻辑段与地址空间"><a href="#逻辑段与地址空间" class="headerlink" title="逻辑段与地址空间"></a>逻辑段与地址空间</h4><p>通过<strong>逻辑段</strong><code>MapArea</code>实现地址空间抽象，指地址区间中的一段实际可用（即 MMU 通过查多级页表 可以正确完成地址转换）的地址连续的<strong>虚拟地址区间</strong>，该区间内包含的所有虚拟页面都以一种相同的方式映射到物理页帧，具有可读&#x2F;可写&#x2F;可执行等属性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="comment">/// map area structure, controls a contiguous piece of virtual memory</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MapArea</span> &#123;</span><br><span class="line">    vpn_range: VPNRange,</span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<strong>恒等映射</strong><code>Identical</code>，虚拟地址与物理地址完全一致，物理页号就等于虚拟页号，无需额外分配新的物理页帧；对Frame映射，可以指定<code>MapType::Framed</code>实现<strong>动态分配</strong>，即虚拟地址不直接对应任何已有的物理地址，而是通过页表映射到操作系统分配的空闲物理页帧，页表项中的物理页号即被分配的物理页帧的物理页号。此时，键值对容器 <code>BTreeMap</code> 中存放的物理页帧被用来存放实际内存数据。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MapArea</span>&#123;	</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ppn</span>: PhysPageNum;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.map_type &#123;</span><br><span class="line">            MapType::Identical =&gt; &#123;</span><br><span class="line">                ppn = <span class="title function_ invoke__">PhysPageNum</span>(vpn.<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            MapType::Framed =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                ppn = frame.ppn;</span><br><span class="line">                <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">insert</span>(vpn, frame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte_flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.map_perm.bits).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        page_table.<span class="title function_ invoke__">map</span>(vpn, ppn, pte_flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> <span class="keyword">self</span>.vpn_range &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">map_one</span>(page_table, vpn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// data: start-aligned but maybe with shorter length</span></span><br><span class="line">    <span class="comment">/// assume that all frames were cleared before</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">copy_data</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, data: &amp;[<span class="type">u8</span>]) &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="keyword">self</span>.map_type, MapType::Framed);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">start</span>: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">current_vpn</span> = <span class="keyword">self</span>.vpn_range.<span class="title function_ invoke__">get_start</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = data.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">src</span> = &amp;data[start..len.<span class="title function_ invoke__">min</span>(start + PAGE_SIZE)];</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">dst</span> = &amp;<span class="keyword">mut</span> page_table</span><br><span class="line">                .<span class="title function_ invoke__">translate</span>(current_vpn)</span><br><span class="line">                .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">                .<span class="title function_ invoke__">ppn</span>()</span><br><span class="line">                .<span class="title function_ invoke__">get_bytes_array</span>()[..src.<span class="title function_ invoke__">len</span>()];</span><br><span class="line">            dst.<span class="title function_ invoke__">copy_from_slice</span>(src);</span><br><span class="line">            start += PAGE_SIZE;</span><br><span class="line">            <span class="keyword">if</span> start &gt;= len &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current_vpn.<span class="title function_ invoke__">step</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map</code>可以对逻辑段所属地址空间的多级页表中加入每个虚拟页面的键值对映射，通过遍历逻辑段内所有虚拟页面而实现。<code>copy_data</code> 方法将切片 <code>data</code> 中的数据拷贝到当前逻辑段实际被内核放置在的各物理页帧上，从而在地址空间中通过该逻辑段就能访问这些数据。</p>
<p><strong>地址空间</strong><code>MemorySet</code>是一系列有关联的逻辑段，用来表明正在运行的应用所在执行环境中的可访问内存空间，在这个内存空间中，包含了一系列的<strong>不一定连续</strong>的逻辑段。这样我们就有任务（进程）的地址空间，内核的地址空间等说法了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="comment">/// address space</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="type">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意， <code>PageTable</code> 下 挂着所有多级页表的节点所在的物理页帧，而每个 <code>MapArea</code> 下则挂着对应逻辑段中的数据所在的物理页帧，这两部分合在一起构成了一个地址空间所需的所有物理页帧。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MemorySet</span>&#123;	</span><br><span class="line">	<span class="comment">/// Assume that no conflicts.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert_framed_area</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        start_va: VirtAddr,</span><br><span class="line">        end_va: VirtAddr,</span><br><span class="line">        permission: MapPermission,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            MapArea::<span class="title function_ invoke__">new</span>(start_va, end_va, MapType::Framed, permission),</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> map_area: MapArea, data: <span class="type">Option</span>&lt;&amp;[<span class="type">u8</span>]&gt;) &#123;</span><br><span class="line">        map_area.<span class="title function_ invoke__">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.page_table);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(data) = data &#123;</span><br><span class="line">            map_area.<span class="title function_ invoke__">copy_data</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.page_table, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.areas.<span class="title function_ invoke__">push</span>(map_area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>push</code> 方法可以在当前地址空间插入一个新的逻辑段 <code>map_area</code> ，如果它是以 <code>Framed</code> 方式映射到 物理内存，还可以可选地在那些被映射到的物理页帧上写入一些初始化数据 <code>data</code>.  而<code>insert_framed_area</code> 方法调用 <code>push</code> ，在当前地址空间插入一个映射到物理内存的逻辑段，该方法需保证同一地址空间内的任意两个逻辑段不能存在交集，从内核和应用的地址空间布局可以看出。</p>
<h4 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h4><p>在分页模式开启之后，内核与应用代码的访存地址都需要通过 MMU 转换变成物理地址，再交给 CPU 的访存单元去访问物理内存。地址空间抽象的重要意义在于 <strong>隔离</strong> (Isolation) ，执行每个应用的代码时，内核都需要控制 MMU 使用此应用地址空间对应的多级页表进行地址转换。每个应用地址空间只能访问自己的数据而无法触及其他应用或是内核的数据。</p>
<p>内核代码的访存地址也会被视为一个虚拟地址，并需要经过 MMU 的地址转换。因此我们需要为内核构造一个地址空间，它除了仍然允许内核的各数据段能够被正常访问之外，还需要包含所有应用的内核栈以及一个<strong>跳板</strong> (Trampoline) .</p>
<p>在<a target="_blank" rel="noopener" href="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html#high-and-low-256gib">最高的256GB与最低的256GB</a>中，曾提过只有最低的256GB<code>0x0000_0000_0000~0x0000_7FFF_FFFF</code>，最高的256GB<code>0xFFFF_8000_0000~0xFFFF_FFFF_FFFF</code>，是可以通过MMU检查的，而中间部分<code>0x0000_8000_0000~0xFFFF_7FFF_FFFF</code>都为非法地址。</p>
<p>下图是软件看到的 64 位地址空间在 SV39 分页模式下实际可能通过 MMU 检查的最高256GB， 跳板放在最高的一个虚拟页面中。接下来则是从高到低放置每个应用的内核栈，内核栈的大小由 <code>config</code> 子模块的 <code>KERNEL_STACK_SIZE</code> 给出。</p>
<img src="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/kernel-as-high.png" alt="最高256GB" style="zoom:67%;" />

<p>相邻两个内核栈之间会预留一个 <strong>保护页面</strong> (Guard Page) ，它是内核地址空间中的空洞，多级页表中并不存在与它相关的映射。 它的意义在于当内核栈空间不足（如调用层数过多或死递归）的时候，代码会尝试访问空洞区域内的虚拟地址，然而它无法在多级页表中找到映射，便会触发异常，此时控制权会交给 trap handler 对这种情况进行 处理。</p>
<p>内核地址空间的低 256GiB 的布局：</p>
<img src="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/kernel-as-low.png" alt="低256GB" style="zoom:67%;" />

<p>四个逻辑段 <code>.text/.rodata/.data/.bss</code> 被恒等映射到物理内存。此外，内核地址空间中需要存在一个恒等映射到内核数据段之外的可用物理页帧的逻辑段，这样才能在启用页表机制之后，内核仍能以纯软件的方式读写这些物理页帧。<code>new_kernel</code>函数作用于创建一个包含低256GiB布局的地址空间，通过<code>push()</code>各逻辑段组成。</p>
<h4 id="应用地址空间"><a href="#应用地址空间" class="headerlink" title="应用地址空间"></a>应用地址空间</h4><p>我们希望效仿内核地址空间的设计，同样借助页表机制使应用地址空间的各个逻辑段也可有不同的访问方式限制，以提早检测应用的错误并及时将其终止。在第三章中，每个应用链接脚本中的起始地址被要求是不同的，这样代码和数据存放的位置才不会产生冲突。现在，所有应用程序都将使用同样的起始地址，所有应用可以使用同一个链接脚本<code>linker.ld</code>.</p>
<img src="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/app-as-full.png" alt="应用地址空间" style="zoom:67%;" />

<p>左侧给出了应用地址空间最低 256GiB 的布局：从 0x0 开始向高地址放置应用内存布局中的各个逻辑段，最后放置带有一个保护页面的用户栈。这些逻辑段都是以 <code>Framed</code> 方式映射到物理内存的。<code>U</code>表示可以在用户特权级时执行访问。右侧则给出了最高的 256GiB ， 它和内核地址空间一样将跳板放置在最高页，还将 Trap 上下文放置在次高页中。</p>
<p>在 <code>os/src/build.rs</code> 中，我们不再将丢弃了所有符号的应用二进制镜像链接进内核，而是直接使用 ELF 格式的可执行文件， 因为在前者中内存布局中各个逻辑段的位置和访问限制等信息都被裁剪掉了。而 <code>loader</code> 子模块也变得极其精简。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/loader.rs</span></span><br><span class="line"><span class="comment">/// Get the total number of applications.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_num_app</span>() <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">_num_app</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; (_num_app <span class="keyword">as</span> <span class="type">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>).<span class="title function_ invoke__">read_volatile</span>() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// get applications data</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_app_data</span>(app_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> [<span class="type">u8</span>] &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">_num_app</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_app_ptr</span> = _num_app <span class="keyword">as</span> <span class="type">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_app</span> = <span class="title function_ invoke__">get_num_app</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_start</span> = <span class="keyword">unsafe</span> &#123; core::slice::<span class="title function_ invoke__">from_raw_parts</span>(num_app_ptr.<span class="title function_ invoke__">add</span>(<span class="number">1</span>), num_app + <span class="number">1</span>) &#125;;</span><br><span class="line">    <span class="built_in">assert!</span>(app_id &lt; num_app);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">            app_start[app_id] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">            app_start[app_id + <span class="number">1</span>] - app_start[app_id],</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处原文档对<code>from_elf()</code>进行了讲解，待补充…</p>
</blockquote>
<h4 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h4><p>SBI初始化完成后，CPU将跳转到内核入口点并在S特权级上运行，此时还未开启分页模式。在内核初始化期间，将过渡到分页模式。</p>
<p>我们先创建内核地址空间的全局实例，这里使用经典的 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 组合是因为我们既需要 <code>Arc&lt;T&gt;</code> 提供的共享引用，也需要 <code>Mutex&lt;T&gt;</code> 提供的互斥访问：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/memory_set.rs</span></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="comment">/// The kernel&#x27;s initial memory mapping(kernel address space)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> KERNEL_SPACE: Arc&lt;UPSafeCell&lt;MemorySet&gt;&gt; =</span><br><span class="line">        Arc::<span class="title function_ invoke__">new</span>(<span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(MemorySet::<span class="title function_ invoke__">new_kernel</span>()) &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>rust_main</code> 函数中，我们首先调用 <code>mm::init</code> 进行内存管理子系统的初始化：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/mod.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> memory_set::KERNEL_SPACE;</span><br><span class="line"><span class="comment">/// initiate heap allocator, frame allocator and kernel space</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>() &#123;</span><br><span class="line">    heap_allocator::<span class="title function_ invoke__">init_heap</span>();</span><br><span class="line">    frame_allocator::<span class="title function_ invoke__">init_frame_allocator</span>();</span><br><span class="line">    KERNEL_SPACE.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">activate</span>();</span><br><span class="line">    <span class="comment">// v3: KERNEL_SPACE.lock().activate();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们最先进行全局动态内存分配器的初始化，接着初始化物理页帧管理器（内含堆数据结构 <code>Vec&lt;T&gt;</code> ）使能可用物理页帧的分配和回收能力。最后创建内核地址空间并让 CPU 开启分页模式， MMU 在地址转换时将使用内核的多级页表。</p>
<p>我们分析内核地址空间创建这一句。首先引用 <code>KERNEL_SPACE</code> ，由于是第一次被使用，此时它会被初始化，调用 <code>MemorySet::new_kernel</code> 创建一个内核地址空间并使用 <code>Arc&lt;UPSafeCell&lt;T&gt;&gt;</code> 包裹起来；</p>
<blockquote>
<p>在 rcore-v3 文档中，内核地址空间被<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>包裹，初始化时调用<code>KERNEL_SPACE.lock().activate()</code>.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span>&#123;</span><br><span class="line">    <span class="comment">/// get the token from the page table</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">token</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="number">8usize</span> &lt;&lt; <span class="number">60</span> | <span class="keyword">self</span>.root_ppn.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据<a target="_blank" rel="noopener" href="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html#satp-layout">实现 SV39 多级页表机制（上） — rCore-Tutorial-Book-v3 0.1 文档</a>，当<code>satp</code>的<code>MODE</code>字段设置为8时，SV39分页机制被启用。<code>PageTable::token</code>用于构造<code>satp</code>开启分页模式，并填充多级页表根节点所在的物理页号。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">MemorySet</span>&#123;</span><br><span class="line">	<span class="comment">/// Change page table by writing satp CSR Register.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">activate</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">satp</span> = <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">token</span>();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            satp::<span class="title function_ invoke__">write</span>(satp);</span><br><span class="line">            asm!(<span class="string">&quot;sfence.vma&quot;</span>);</span><br><span class="line">            <span class="comment">// v3: llvm_asm!(&quot;sfence.vma&quot; :::: &quot;volatile&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>activate</code>将得到的<code>token</code>作为<code>satp</code>写入。<code>sfence.vma</code>包含清空快表TLB的操作。</p>
<p>注意，切换satp的指令附近的映射必须连续性，切换 satp 的指令及其下一条指令这两条相邻的指令的虚拟地址是相邻的。此处，这条写入 satp 的指令及其下一条指令都在内核内存布局的代码段中，在切换之后是一个恒等映射， 而在切换之前是视为物理地址直接取指，也可以将其看成一个恒等映射。这完全符合我们的期待：即使切换了地址空间，指令仍应该能够被<strong>连续</strong>的执行。</p>
<p>此外，我们可用<code>mm::remap_test</code>函数检查<code>mm:init</code>之后内核地址空间的多级页表是否被正确设置，分别通过手动查内核多级页表的方式验证代码段和只读数据段不允许被写入，同时不允许从数据段上取指。</p>
<h4 id="跳板Trampoline"><a href="#跳板Trampoline" class="headerlink" title="跳板Trampoline"></a>跳板Trampoline</h4><p>在启用分页机制后，对于Trap处理时我们需要修改satp以完成应用&#x2F;内核地址空间的切换。地址空间的切换不能影响指令的连续执行，即要求应用和内核地址空间在切换地址空间指令附近是平滑的。</p>
<blockquote>
<p>Q：为什么将 Trap 上下文放到应用地址空间的次高页面而不是内核地址空间中的内核栈中呢？</p>
<p>A：为了在内核栈中保存上下文，需要以下步骤：</p>
<ul>
<li>切换到内核地址空间<ul>
<li>将内核地址空间的 token 写入 <code>satp</code> 寄存器（切换页表）。</li>
</ul>
</li>
<li>定位内核栈顶<ul>
<li>需要一个通用寄存器保存内核栈的栈顶指针。</li>
</ul>
</li>
</ul>
<p>但硬件只提供了一个 <code>sscratch</code> 寄存器作为临时寄存器，无法同时保存两个信息。这会导致寄存器冲突。因此，我们在应用地址空间的次高页面预留一个虚拟页面，专门用于保存 Trap 上下文。当 Trap 发生时：</p>
<ul>
<li>硬件直接使用当前地址空间（即应用的页表）定位上下文保存位置。</li>
<li>无需切换到内核地址空间，也无需额外的寄存器来保存内核栈信息。</li>
</ul>
</blockquote>
<p>此处，上下文新添加的内容在初始化之后，只会被读取而不会被写入 ，无需每次都保存或恢复。在应用初始化时由内核写入应用地址空间中的 TrapContext 的相应位置，此后就不再被修改。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/trap/context.rs</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="comment">/// trap context structure containing sstatus, sepc and registers</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TrapContext</span> &#123;</span><br><span class="line">    <span class="comment">/// General-Purpose Register x0-31</span></span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="type">usize</span>; <span class="number">32</span>],</span><br><span class="line">    <span class="comment">/// Supervisor Status Register</span></span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="comment">/// Supervisor Exception Program Counter</span></span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// *Token of kernel address space</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_satp: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// *Kernel stack pointer of the current application</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_sp: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// *Virtual address of trap handler entry point in kernel</span></span><br><span class="line">    <span class="keyword">pub</span> trap_handler: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>trap.S</code>与<code>linker.ld</code>汇编代码部分待补充</p>
</blockquote>
<p>刚产生trap时，CPU已经进入了内核态（即Supervisor Mode），但此时执行代码和访问数据还是在应用程序所处的用户态虚拟地址空间中。为保持CPU指令的连续执行，应用的用户态虚拟地址空间 和 操作系统内核的内核态虚拟地址空间 对切换地址空间的指令所在页的映射方式均是相同的。无论是内核还是应用的地址空间，跳板的虚拟页均位于同样位置，且它们也将会映射到同一个 实际存放这段 汇编代码的物理页帧。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/OS/" rel="tag"># OS</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/10/21/OS%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/" rel="prev" title="rCore-1">
                  <i class="fa fa-angle-left"></i> rCore-1
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">wdlin233</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">49k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:29</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>




<span id="sitetime"></span>
<script language=javascript>
	function siteTime(){
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000;
		var minutes = seconds * 60;
		var hours = minutes * 60;
		var days = hours * 24;
		var years = days * 365;
		var today = new Date();
		var todayYear = today.getFullYear();
		var todayMonth = today.getMonth()+1;
		var todayDate = today.getDate();
		var todayHour = today.getHours();
		var todayMinute = today.getMinutes();
		var todaySecond = today.getSeconds();
		/* 
		Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
		year - 作为date对象的年份，为4位年份值
		month - 0-11之间的整数，做为date对象的月份
		day - 1-31之间的整数，做为date对象的天数
		hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
		minutes - 0-59之间的整数，做为date对象的分钟数
		seconds - 0-59之间的整数，做为date对象的秒数
		microseconds - 0-999之间的整数，做为date对象的毫秒数
        */
		var t1 = Date.UTC(2024,10,20,00,00,00); //北京时间2021-8-11 00:00:00
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		var diff = t2-t1;
		var diffYears = Math.floor(diff/years);
		var diffDays = Math.floor((diff/days)-diffYears*365);
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		document.getElementById("sitetime").innerHTML=" 本站已悄悄运行"+/*diffYears+" 年 "+*/diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
	}
	siteTime();
</script>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
