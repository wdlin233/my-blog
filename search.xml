<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Rust学习日志-Rustlings</title>
    <url>/2024/10/20/Rust%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-Rustlings/</url>
    <content><![CDATA[<h4 id="2024-9-29"><a href="#2024-9-29" class="headerlink" title="2024&#x2F;9&#x2F;29"></a>2024&#x2F;9&#x2F;29</h4><p>配置环境，WSL2下的Rust环境及WSL2与vscode的连接</p>
<h4 id="2024-10-1"><a href="#2024-10-1" class="headerlink" title="2024&#x2F;10&#x2F;1"></a>2024&#x2F;10&#x2F;1</h4><p>复习一下先前学的所有权与引用相关的知识，还有Rust中字符串的处理。稍微看了下方法 Method的使用。</p>
<p>可变引用与不可变引用的核心就在于：<strong>同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用</strong>。</p>
<p>完成Rustlings的struct和enums习题(31-36)。</p>
<p>enums3需要match表达式的相关知识，学习了一点模式匹配。</p>
<p>又做了strings(37-40).</p>
<span id="more"></span>

<h4 id="2024-10-2"><a href="#2024-10-2" class="headerlink" title="2024&#x2F;10&#x2F;2"></a>2024&#x2F;10&#x2F;2</h4><p>做练习的进度跟不上学习语法的进度，继续读Rust Course，有些地方还是不理解，尤其是Trait的部分。感觉看完能够看懂，但是不知道整体这么设计的目的。似乎Trait是Rust实现与C++继承类似的功能而做的复用性设计，而特征变量就是复用不同的Trait，再做了一层抽象。</p>
<p>读2.8泛型与特征、2.9集合类型、2.12包与模块。</p>
<p>写modules和hashmaps(41-46).</p>
<p>写hashmaps3(46)时有一个疑惑，<code>or_insert()</code>应返回一个<code>&amp; mut v</code>的引用类型，<strong>使用引用时应当先解引用</strong>，但我可以直接写<code>v1.goals_scored += team_1_score</code>. 不知道是为什么？</p>
<p>再做options(47-49).</p>
<p>errors1(50).</p>
<h4 id="2024-10-3"><a href="#2024-10-3" class="headerlink" title="2024&#x2F;10&#x2F;3"></a>2024&#x2F;10&#x2F;3</h4><p>继续Rustlings(errors2-6, 51-55, generics1-2, 56-57, traits 58-62). </p>
<p>做errors2和errors3的时候，总算明白了之前出现多次的<code>.unwrap()</code>的含义，就是取正确返回的<code>Result</code> 或 <code>Option</code> 类型的返回值。另外还遇到了<code>.unwrap_err().to_string()</code>这个操作，<code>unwrap_err()</code>的意思是，将<code>Ok()</code>或者<code>Err()</code>中的值取出并报错。参考<a href="https://blog.csdn.net/weixin_40482577/article/details/137244187">RUST 中什么情况下要使用 .unwrap ( )_rust unwrap-CSDN博客</a>.</p>
<p>errors5使用<code>Box&lt;dyn error::Error&gt;</code>，还是不是很理解Box是怎么使用。在这里是<code>Result&lt;_, E&gt;</code>的返回值，为什么最后使用的是<code>error:Error</code>?</p>
<p>errors6似懂非懂，可以理解到需要<code>CreationError</code>和<code>ParseIntError</code>两种错误类型的检测。所以似乎是先用一层<code>map_err()?</code>，之后再用一层<code>map_err()</code>. 检测两次。</p>
<p>traits5此处运用了多重约束，本质上是一个泛型为基础的语法糖，在<a href="https://course.rs/basic/trait/trait.html#%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9Ftrait-bound">Rust语言圣经</a>中有详细讨论。</p>
<h4 id="2024-10-4"><a href="#2024-10-4" class="headerlink" title="2024&#x2F;10&#x2F;4"></a>2024&#x2F;10&#x2F;4</h4><p>继续做tests.(63-68)</p>
<p>tests5有点令人疑惑，传入值是<code>&amp;mut t as *mut u32 as usize</code>，感觉令人无从下手。经过其自带注释的启发，先将传入的<code>mut address: usize</code>转为<code>*mut u32</code>的指针类型，再对指针所指向地址解引用修改即可。 </p>
<p>tests6考察的是用<code>into_raw()</code>创建野指针的处理方式，可见<a href="https://course.rs/advance/unsafe/superpowers.html?highlight=into_raw#%E5%9F%BA%E4%BA%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E8%A3%B8%E6%8C%87%E9%92%88">五种兵器 - Rust语言圣经(Rust Course)</a>，及<a href="https://vimsky.com/examples/usage/rust-std-boxed-struct.Box.into_raw-rt.html">Rust Box.into_raw用法及代码示例 - 纯净天空 (vimsky.com)</a>. 答案需要用到<code>from_raw()</code>来取指针，并对<code>*ptr.b</code>进行修改。</p>
<p><strong>果然不会做就应该及时看hint</strong>，此时的各种知识已经不是根据Rust圣经的排序了。</p>
<p>另外复习一下<code>to_owned()</code>这个函数，是获得其所有权的。参见<a href="https://zhuanlan.zhihu.com/p/687511216#:-:text=to_owned">Rust 的 to_owned 和 clone 的区别 - 知乎 (zhihu.com)</a>. 在tests6中，运用于<code>assert!(ret.b == Some(&quot;hello&quot;.to_owned()));</code></p>
<h4 id="2024-10-5"><a href="#2024-10-5" class="headerlink" title="2024&#x2F;10&#x2F;5"></a>2024&#x2F;10&#x2F;5</h4><p>tests7和tests8都是用<code>println!</code>输出命令，tests7是环境变量，tests8是条件编译。这里试错了很久，主要是不了解cargo这里的命令该如何使用。比较笨的是忘了使用<code>\</code>对<code>&quot;</code>进行转义。<a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-env">Build Scripts - The Cargo Book (rust-lang.org)</a>和<a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-cfg">Build Scripts - The Cargo Book (rust-lang.org)</a></p>
<p>tests9是<code>#[no_mangle]</code>的应用，似乎是因为外部引用会导致函数名称的变化，这个属性就是让其保持原有的名称，不过我又重新定义了<code>my_demo_function_alias</code>这个函数，我怀疑我写错了，之后再看看。参考<a href="https://rustwiki.org/zh-CN/std/keyword.extern.html">extern - Rust (rustwiki.org)</a></p>
<p>lifetimes1, lifetimes2和lifetimes3都是圣经上的例子。</p>
<p>值得一提的是lifetimes3，是对结构体设置生命周期。或许可以说，我要让结构体和结构体内的成员处于同一作用域内，圣经<a href="https://course.rs/basic/compound-type/struct.html#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83">结构体 - Rust语言圣经(Rust Course)</a>中写：</p>
<blockquote>
<p>在之前的 <code>User</code> 结构体的定义中，有一处细节：我们使用了自身拥有所有权的 <code>String</code> 类型而不是基于引用的 <code>&amp;str</code> 字符串切片类型。这是一个有意而为之的选择：因为我们想要这个结构体拥有它所有的数据，而不是从其它地方借用数据</p>
</blockquote>
<p>Rutslings69-74.</p>
<h4 id="2024-10-7"><a href="#2024-10-7" class="headerlink" title="2024&#x2F;10&#x2F;7"></a>2024&#x2F;10&#x2F;7</h4><p>Rustlings(75-79, 80).</p>
<p>学习迭代器Iterator.</p>
<p>iterators2说是迭代器，不如说更多是字符串的操作. 看了hint后，说<code>first</code>是一个<code>char</code>. 看圣经说<code>next()</code>是一个消费者适配器，在这里似乎是将<code>c</code>的第一个字母去除了，但之后其他的字母都留存在<code>c</code>中，所以可以使用<code>as_str()</code>来转换.</p>
<blockquote>
<p>The variable <code>first</code> is a <code>char</code>. It needs to be capitalized and added to the remaining characters in <code>c</code> in order to return the correct <code>String</code>. The remaining characters in <code>c</code> can be viewed as a string slice using the<code>as_str</code> method.</p>
</blockquote>
<p>iterators4不知道该怎么用迭代器来实现，这里用<code>(1..num+1).product()</code>非常巧妙.</p>
<p>iterators5这里的类型有点令人困惑，我查询<code>.values()</code>函数得到</p>
<blockquote>
<p>pub fn <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#method.values">values</a>(&amp;self) -&gt; <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.Values.html">Values</a>&lt;’_, K, V&gt; <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#">ⓘ</a><br>An iterator visiting all values in arbitrary order. The iterator element type is <code>&amp;&#39;a V</code></p>
</blockquote>
<p>所以在使用<code>filter()</code>指定类型时，应写<code>map.values().filter(|&amp;x| *x == value).count()</code></p>
<p>对于<code>flat_map()</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">words</span> = [<span class="string">&quot;alpha&quot;</span>, <span class="string">&quot;beta&quot;</span>, <span class="string">&quot;gamma&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// chars() returns an iterator</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">merged</span>: <span class="type">String</span> = words.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">                          .<span class="title function_ invoke__">flat_map</span>(|s| s.<span class="title function_ invoke__">chars</span>())</span><br><span class="line">                          .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(merged, <span class="string">&quot;alphabetagamma&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>所以<code>collection.iter().flat_map(|x| x.values()).filter(|&amp;x| *x == value).count() </code>中的<code>x.values()</code>似乎就是返回一个迭代器对象，对迭代器中的每个元素再单独创建一个迭代器对象，该迭代器只有一个元素.</p>
<hr>
<p>再学习多线程thread. <code>join()</code>方法可以让当前线程阻塞等待多线程的完成. <code>thread::spawn</code>取得的对象是<code>JoinHandle&lt;u128&gt;</code>，故需要用’<code>join()</code>取得. 我们得到的是<code>Result</code>类型，需要用<code>expect()</code>取得<code>Ok</code>值，若不成功取得则返回错误信息.</p>
<h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><blockquote>
<p>To learn when a thread completes, it is necessary to capture the <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html"><code>JoinHandle</code></a> object that is returned by the call to <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>spawn</code></a>, which provides a <code>join</code> method that allows the caller to wait for the completion of the spawned thread:</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">thread_join_handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="comment">// some work here</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// some work here</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">res</span> = thread_join_handle.<span class="title function_ invoke__">join</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join"><code>join</code></a> method returns a <a href="https://doc.rust-lang.org/std/thread/type.Result.html"><code>thread::Result</code></a> containing <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a> of the final value produced by the spawned thread, or <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a> of the value given to a call to <a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a> if the thread panicked.</p>
</blockquote>
<h5 id="expect"><a href="#expect" class="headerlink" title="expect()"></a>expect()</h5><blockquote>
<p>Returns the contained <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a> value, consuming the <code>self</code> value.</p>
<p>Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a> case explicitly, or call <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or"><code>unwrap_or</code></a>, <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else"><code>unwrap_or_else</code></a>, or <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_default"><code>unwrap_or_default</code></a>.</p>
<p>Panics if the value is an <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a>, with a panic message including the passed message, and the content of the <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a>.</p>
</blockquote>
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">Result in std::result - Rust (rust-lang.org)</a></p>
<p>另外，对于经常出现的<code>unwrap()</code>函数，也做下记录：对于<code>Option</code>取<code>Some</code>的值，对于<code>Result</code>取<code>Ok</code>的值.</p>
<h4 id="2024-10-8"><a href="#2024-10-8" class="headerlink" title="2024&#x2F;10&#x2F;8"></a>2024&#x2F;10&#x2F;8</h4><p>多线程的锁结构需要智能指针的知识，再补.</p>
<p>Rustlings(81-82, 83-84).</p>
<p><strong>常规引用是一个指针类型</strong>，包含了目标数据存储的内存地址。对常规引用使用 <code>*</code> 操作符，就可以通过解引用的方式获取到内存地址对应的数据值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 <code>Deref</code> 后的智能指针结构体，就可以像普通引用一样，通过 <code>*</code> 进行解引用，例如 <code>Box&lt;T&gt;</code> 智能指针：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = *x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code> 类型，它其实是一个<strong>智能指针结构体</strong>. 对于函数和方法的传参，Rust 提供了一个极其有用的隐式转换：<code>Deref </code>转换。若一个类型实现了 <code>Deref</code> 特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行<strong>隐式的 <code>Deref</code> 转换</strong>，例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你以为 <code>Deref</code> 仅仅这点作用，那就大错特错了。<code>Deref</code> 可以支持连续的隐式转换，直到找到适合的形式为止：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>引用计数机制：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">2</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a), Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码我们使用 <code>Rc::new</code> 创建了一个新的 <code>Rc&lt;String&gt;</code> 智能指针并赋给变量 <code>a</code>，该指针指向底层的字符串数据。</p>
<p>智能指针 <code>Rc&lt;T&gt;</code> 在创建时，还会将引用计数加 1，此时获取引用计数的关联函数 <code>Rc::strong_count</code> 返回的值将是 <code>1</code>。</p>
<p>接着，我们又使用 <code>Rc::clone</code> 克隆了一份智能指针 <code>Rc&lt;String&gt;</code>，并将该智能指针的引用计数增加到 <code>2</code>。</p>
<p>由于 <code>a</code> 和 <code>b</code> 是同一个智能指针的两个副本，因此通过它们两个获取引用计数的结果都是 <code>2</code>。</p>
<p>不要被 <code>clone</code> 字样所迷惑，以为所有的 <code>clone</code> 都是深拷贝。这里的 <code>clone</code> <strong>仅仅复制了智能指针并增加了引用计数，并没有克隆底层数据</strong>，因此 <code>a</code> 和 <code>b</code> 是共享了底层的字符串 <code>s</code>，这种<strong>复制效率是非常高</strong>的。当然你也可以使用 <code>a.clone()</code> 的方式来克隆，但是从可读性角度，我们更加推荐 <code>Rc::clone</code> 的方式。</p>
<hr>
<p>因为<code>Mutex&lt;T&gt;</code>是一个智能指针，准确的说是<code>m.lock()</code>返回一个智能指针<code>MutexGuard&lt;T&gt;</code></p>
<ul>
<li>它实现了<code>Deref</code>特征，会被自动解引用后获得一个引用类型，该引用指向<code>Mutex</code>内部的数据</li>
<li>它还实现了<code>Drop</code>特征，在超出作用域后，自动释放锁，以便其它线程能继续获取锁</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用`Mutex`结构体的关联函数创建新的互斥锁实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取锁，然后deref为`m`的引用</span></span><br><span class="line">        <span class="comment">// lock返回的是Result</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">// 锁自动被drop</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;:?&#125;&quot;</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前章节，我们提到过<a href="https://course.rs/advance/smart-pointer/cell-refcell.html#%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7">内部可变性</a>，其中<code>Rc&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>的结合，可以实现单线程的内部可变性。</p>
<p>现在我们又有了新的武器，由于<code>Mutex&lt;T&gt;</code>可以支持修改内部数据，当结合<code>Arc&lt;T&gt;</code>一起使用时，可以实现多线程的内部可变性。</p>
<p>简单总结下：<code>Rc&lt;T&gt;/RefCell&lt;T&gt;</code>用于单线程内部可变性， <code>Arc&lt;T&gt;/Mutex&lt;T&gt;</code>用于多线程内部可变性。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>threads2是<code>Mutex</code>和<code>Arc</code>的综合运用，还结合了结构体，有点复杂. 关键在于<code>status_shared.lock().unwrap().jobs_completed += 1;</code>这个复合，最后输出也是类似，<code>println!(&quot;jobs completed &#123;&#125;&quot;, status.lock().unwrap().jobs_completed);</code>即可.</p>
<p>threads3和圣经中多发送者<a href="https://course.rs/advance/concurrency-with-threads/message-passing.html#%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%8F%91%E9%80%81%E8%80%85">线程同步：消息传递 - Rust语言圣经(Rust Course)</a>的例子很相似：由于子线程会拿走发送者的所有权，因此我们必须对发送者进行克隆，然后让每个线程拿走它的一份拷贝: <code>let tx1 = tx.clone();</code>.</p>
<p>Box1是圣经里的例子<a href="https://course.rs/advance/smart-pointer/box.html#%E5%B0%86%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B%E5%8F%98%E4%B8%BA-sized-%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B">Box堆对象分配 - Rust语言圣经(Rust Course)</a>，避免动态大小类型而在定义时使用<code>Box&lt;T&gt;</code>.</p>
<h4 id="2024-10-9"><a href="#2024-10-9" class="headerlink" title="2024&#x2F;10&#x2F;9"></a>2024&#x2F;10&#x2F;9</h4><p>Rustlings(85-86, 87-90, 91-93).</p>
<p>cow1使用<code>Cow</code>这个智能指针，处理的是所有权与可修改的问题。当其数据不拥有所有权时，不修改内容就返回不可变引用，修改内容便返回可变引用.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Cow</span>&lt;<span class="symbol">&#x27;a</span>, B&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    B: <span class="symbol">&#x27;a</span> + <span class="built_in">ToOwned</span> + ?<span class="built_in">Sized</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">Borrowed</span>(&amp;<span class="symbol">&#x27;a</span> B),</span><br><span class="line">    <span class="title function_ invoke__">Owned</span>(&lt;B <span class="keyword">as</span> <span class="built_in">ToOwned</span>&gt;::Owned),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::borrow::Cow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">abs_all</span>(input: &amp;<span class="keyword">mut</span> Cow&lt;<span class="symbol">&#x27;_</span>, [<span class="type">i32</span>]&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..input.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v</span> = input[i];</span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Clones into a vector if not already owned.</span></span><br><span class="line">            input.<span class="title function_ invoke__">to_mut</span>()[i] = -v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No clone occurs because `input` doesn&#x27;t need to be mutated.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = Cow::<span class="title function_ invoke__">from</span>(&amp;slice[..]);</span><br><span class="line"><span class="title function_ invoke__">abs_all</span>(&amp;<span class="keyword">mut</span> input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clone occurs because `input` needs to be mutated.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = Cow::<span class="title function_ invoke__">from</span>(&amp;slice[..]);</span><br><span class="line"><span class="title function_ invoke__">abs_all</span>(&amp;<span class="keyword">mut</span> input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// No clone occurs because `input` is already owned.</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = Cow::<span class="title function_ invoke__">from</span>(<span class="built_in">vec!</span>[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="title function_ invoke__">abs_all</span>(&amp;<span class="keyword">mut</span> input);</span><br></pre></td></tr></table></figure>

<p>macros3在<code>mod</code>前加入<code>#[macro_use]</code>即可. 文件内结构如下:</p>
<ul>
<li>macros3<ul>
<li>mod my_macro</li>
<li>main</li>
</ul>
</li>
</ul>
<p>这里用的宏都不是很复杂，题目也只涉及基本的概念，感觉只是会用宏但是自己不会写.</p>
<p>clippy1想自己定义<code>pi</code>但失败，因为默认<code>#[deny(clippy::approx_constant)]</code>是开启的，可以使用<code>f32::consts::PI</code>.</p>
<p>clippy2和clippy3感觉都是需要我们避免的低级错误.</p>
<h4 id="2024-10-10"><a href="#2024-10-10" class="headerlink" title="2024&#x2F;10&#x2F;10"></a>2024&#x2F;10&#x2F;10</h4><p>读Weak与循环引用以及链表实现的部分内容.</p>
<p>conversations(94-98, 99-100)</p>
<p>对于<code>AsRef</code>:</p>
<blockquote>
<p>By creating a generic function that takes an <code>AsRef&lt;str&gt;</code> we express that we want to accept all references that can be converted to <a href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a> as an argument. Since both <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> and <a href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a> implement <code>AsRef&lt;str&gt;</code> we can accept both as input argument.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">is_hello</span>&lt;T: <span class="built_in">AsRef</span>&lt;<span class="type">str</span>&gt;&gt;(s: T) &#123;</span><br><span class="line">   <span class="built_in">assert_eq!</span>(<span class="string">&quot;hello&quot;</span>, s.<span class="title function_ invoke__">as_ref</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">is_hello</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="title function_ invoke__">is_hello</span>(s);</span><br></pre></td></tr></table></figure>

<p><code>AsMut</code>类似:</p>
<blockquote>
<p>Using <code>AsMut</code> as trait bound for a generic function, we can accept all mutable references that can be converted to type <code>&amp;mut T</code>.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rustlings: as_ref_mut.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">num_sq</span>&lt;T: <span class="built_in">AsMut</span>&lt;<span class="type">u32</span>&gt;&gt;(arg: &amp;<span class="keyword">mut</span> T) &#123;</span><br><span class="line">    *arg.<span class="title function_ invoke__">as_mut</span>() *= *arg.<span class="title function_ invoke__">as_mut</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>复习一下<code>collect()</code>的用法:</p>
<blockquote>
<p>Transforms an iterator into a collection.</p>
<p><code>collect()</code> can take anything iterable, and turn it into a relevant collection. This is one of the more powerful methods in the standard library, used in a variety of contexts.</p>
<p><code>collect()</code> can also create instances of types that are not typical collections. For example, a <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> can be built from <a href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a>s, and an iterator of <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> items can be collected into <code>Result&lt;Collection&lt;T&gt;, E&gt;</code>. See the examples below for more.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">doubled</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = a.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">                         .<span class="title function_ invoke__">map</span>(|&amp;x| x * <span class="number">2</span>)</span><br><span class="line">                         .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>], doubled);</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">results</span> = [<span class="title function_ invoke__">Ok</span>(<span class="number">1</span>), <span class="title function_ invoke__">Err</span>(<span class="string">&quot;nope&quot;</span>), <span class="title function_ invoke__">Ok</span>(<span class="number">3</span>), <span class="title function_ invoke__">Err</span>(<span class="string">&quot;bad&quot;</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;_&gt;, &amp;<span class="type">str</span>&gt; = results.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// gives us the first error</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Err</span>(<span class="string">&quot;nope&quot;</span>), result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">results</span> = [<span class="title function_ invoke__">Ok</span>(<span class="number">1</span>), <span class="title function_ invoke__">Ok</span>(<span class="number">3</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;_&gt;, &amp;<span class="type">str</span>&gt; = results.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// gives us the list of answers</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Ok</span>(<span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">3</span>]), result);</span><br></pre></td></tr></table></figure>

<h4 id="2024-10-11"><a href="#2024-10-11" class="headerlink" title="2024&#x2F;10&#x2F;11"></a>2024&#x2F;10&#x2F;11</h4><p>quiz2: <a href="https://rustcc.cn/article?id=5111a32a-8134-4e4f-b9c1-17a1c354748c">话说to_string(), into(), to_owned(), from()区别是什么</a>讲解了字符串相关的几个函数.</p>
<blockquote>
<p><code>to_owned()</code>creates owned data from borrowed data, usually by cloning.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="type">str</span> = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ss</span>: <span class="type">String</span> = s.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: &amp;[<span class="type">i32</span>] = &amp;[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">vv</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = v.<span class="title function_ invoke__">to_owned</span>();</span><br></pre></td></tr></table></figure>

<p>其余的，<code>into()</code>是基于<code>Into</code>特征，实现类型转换；<code>from()</code>基于<code>From</code>特征，将类型<code>T</code>转换为指导类型，与<code>into()</code>对称；<code>to_string</code>是<code>ToString</code>特征的一部分，当一个类型实现<code>Display</code>特征时就会自动实现<code>ToString</code>.</p>
<h5 id="String-and-str"><a href="#String-and-str" class="headerlink" title="String and &amp;str"></a>String and &amp;str</h5><p>对于如下代码段，</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Command::<span class="title function_ invoke__">Append</span>(x) =&gt; string + &amp;<span class="string">&quot;bar&quot;</span>.<span class="title function_ invoke__">repeat</span>(*x)</span><br></pre></td></tr></table></figure>

<p>编译器会报错 </p>
<blockquote>
<p><code>+</code> cannot be used to concatenate two <code>&amp;str</code> strings.</p>
</blockquote>
<p>这里的关系有点复杂，我问了GPT-4o. 回答说:</p>
<p><code>&quot;bar&quot;.repeat(*x)</code> 会创建一个新的 <code>String</code>，因此 <code>&amp;&quot;bar&quot;.repeat(*x)</code> 的类型是 <code>&amp;String</code>, 而<code>string</code>变量得到的是<code>&amp;String</code>类型.</p>
<p><strong><code>+</code> 操作符需要左操作数是一个拥有所有权的 <code>String</code>，右操作数是一个 <code>&amp;str</code></strong>. 因此，当你使用 <code>string + &amp;&quot;bar&quot;.repeat(*x)</code> 时，存在类型不匹配的问题：</p>
<ul>
<li><code>string</code> 实际上是 <code>&amp;String</code>（需要转换为 <code>String</code>）</li>
<li><code>&amp;&quot;bar&quot;.repeat(*x)</code> 是 <code>&amp;String</code>（需要转换为 <code>&amp;str</code>）</li>
</ul>
<p>要解决这个问题，确保左操作数是一个 <code>String</code> 类型：</p>
<ul>
<li>使用 <code>string.to_owned()</code> 或 <code>string.clone()</code> 将 <code>&amp;String</code> 转为 <code>String</code>，以符合 <code>+</code> 操作符的要求：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Command::<span class="title function_ invoke__">Append</span>(x) =&gt; string.<span class="title function_ invoke__">to_owned</span>() + &amp;<span class="string">&quot;bar&quot;</span>.<span class="title function_ invoke__">repeat</span>(*x)</span><br></pre></td></tr></table></figure>

<p>这样操作后，<code>string.to_owned()</code> 会变成 <code>String</code> 类型，而 <code>&amp;&quot;bar&quot;.repeat(*x)</code> 会被<strong>自动解引用</strong>为 <code>&amp;str</code>，适合 <code>+</code> 操作符的要求。</p>
<p>网上的一些解答也显示，在此处<code>to_owned()</code>, <code>to_string()</code>, <code>into()</code>都可以.</p>
<hr>
<h5 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h5><p>参见 <a href="https://course.rs/basic/formatted-output.html">格式化输出 - Rust语言圣经(Rust Course)</a>.</p>
<p>与 <code>&#123;&#125;</code> 类似，<code>&#123;:?&#125;</code> 也是占位符：</p>
<ul>
<li><code>&#123;&#125;</code> 适用于实现了 <code>std::fmt::Display</code> 特征的类型，用来以更优雅、更友好的方式格式化文本，例如展示给用户</li>
<li><code>&#123;:?&#125;</code> 适用于实现了 <code>std::fmt::Debug</code> 特征的类型，用于调试场景</li>
</ul>
<p>其实两者的选择很简单，当你在写代码需要调试时，使用 <code>&#123;:?&#125;</code>，剩下的场景，选择 <code>&#123;&#125;</code>。</p>
<h6 id="Debug特征"><a href="#Debug特征" class="headerlink" title="Debug特征"></a>Debug特征</h6><p>事实上，为了方便我们调试，大多数 Rust 类型都实现了 <code>Debug</code> 特征或者支持派生该特征：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person&#123;name: <span class="string">&quot;sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(), age: <span class="number">18</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;</span>, i, s, v, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于数值、字符串、数组，可以直接使用 <code>&#123;:?&#125;</code> 进行输出，但是对于结构体，需要<a href="https://course.rs/appendix/derive.html">派生Debug</a>特征后，才能进行输出，总之很简单.</p>
<h6 id="Display特征"><a href="#Display特征" class="headerlink" title="Display特征"></a>Display特征</h6><p>与大部分类型实现了 <code>Debug</code> 不同，实现了 <code>Display</code> 特征的 Rust 类型并没有那么多，往往需要我们自定义想要的格式化方式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">i</span> = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">    name: <span class="string">&quot;sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, i, s, v, p);</span><br></pre></td></tr></table></figure>

<p>运行后可以看到 <code>v</code> 和 <code>p</code> 都无法通过编译，因为没有实现 <code>Display</code> 特征，但是你又不能像派生 <code>Debug</code> 一般派生 <code>Display</code>，只能另寻他法：</p>
<ul>
<li>使用 <code>&#123;:?&#125;</code> 或 <code>&#123;:#?&#125;</code></li>
<li>为自定义类型实现 <code>Display</code> 特征</li>
<li>使用 <code>newtype</code> 为外部类型实现 <code>Display</code> 特征</li>
</ul>
<p>一个比较经典的例子就是为结构体实现<code>Display</code>特征.</p>
<p>quiz3中的<code>impl&lt;T: std::fmt::Display&gt; ReportCard&lt;T&gt;</code>就是结合了结构体的<code>Display</code>特征与结构体内泛型数据的实现.</p>
<hr>
<p>algorithm1, 感觉还是有点难度，需要为泛型<code>T</code>实现<code>Ord</code>和<code>Clone</code>特征，然后在建立链表时和取变量时注意带上泛型的标注即可.</p>
<h4 id="2024-10-12"><a href="#2024-10-12" class="headerlink" title="2024&#x2F;10&#x2F;12"></a>2024&#x2F;10&#x2F;12</h4><p>algorithm2可以首先转换首尾节点<code>std::mem::swap(&amp;mut self.start, &amp;mut self.end);</code>.</p>
<p>然后我们可以考虑将包括头尾的所有节点的前驱指针与后继指针转换，这样头指针将会从后往前指向尾指针.</p>
<p>关键在于Rust中的指针操作:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(current_ptr) = current &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">node</span> = &amp;<span class="keyword">mut</span> *current_ptr.<span class="title function_ invoke__">as_ptr</span>();</span><br><span class="line">        <span class="comment">// 交换 next 和 prev 指针</span></span><br><span class="line">        std::mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> node.next, &amp;<span class="keyword">mut</span> node.prev);</span><br><span class="line">        <span class="comment">// 移动到下一个节点</span></span><br><span class="line">        current = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里解引用了裸指针，所以需要使用<code>unsafe</code>. 再者，<code>as_ptr()</code>是因为，直接解引用 <code>NonNull</code> 或裸指针违背了 Rust 的安全保证，因为这对后端优化器和静态分析器来说指针的变动的信息。所以我们需要使用 <code>as_ptr()</code> 返回一个原始指针，并告诉编译器“我知道我在使用一个底层指针”（这与 Rust 强类型系统的设计哲学一致：使你更清晰地表达你的意图）. </p>
<p>获取 <code>current_ptr</code> 所指向的节点的可变引用。<code>as_ptr()</code> 将 <code>NonNull</code> 转换为裸指针，而 <code>&amp;mut *</code> 会解引用裸指针并获取节点.</p>
<p>algorithms3思路不难，主要是其中各种API. 例如<code>len()</code>和<code>swap()</code>. 参见<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.swap">Vec in std::vec - Rust (rust-lang.org)</a></p>
<p>algorithm4主要还是递归，有几个需要注意:</p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p><strong>模式匹配时使用<code>ref</code>防止所有权转移</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">match</span> <span class="keyword">self</span>.root &#123;</span><br><span class="line">     <span class="title function_ invoke__">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> node) =&gt; node.<span class="title function_ invoke__">insert</span>(value),</span><br><span class="line">     <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">         <span class="keyword">self</span>.root = <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(TreeNode::<span class="title function_ invoke__">new</span>(value)));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="keyword">self</span>.root &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(node) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 这里使用了 node 的所有权</span></span><br><span class="line">        <span class="built_in">assert!</span>(node.left.<span class="title function_ invoke__">is_none</span>());</span><br><span class="line">        <span class="built_in">assert!</span>(node.right.<span class="title function_ invoke__">is_none</span>());</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Root should not be None after insertion&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>self.root</code> 为 <code>Some(node)</code>，那么 <code>node</code> 的所有权将被移动到这个模式内。</li>
<li>结果是，<code>self.root</code> 将变成无效的，因为它的内容（即 <code>node</code>）已经被移动，而 Rust 不允许重复使用已经被移动的变量。</li>
</ul>
<h4 id="2024-10-13"><a href="#2024-10-13" class="headerlink" title="2024&#x2F;10&#x2F;13"></a>2024&#x2F;10&#x2F;13</h4><h5 id="map-or"><a href="#map-or" class="headerlink" title="map_or()"></a>map_or()</h5><p>对于搜索结果，我们可以使用<code>map_or()</code>来处理.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_or</span>&lt;U, F&gt;(<span class="keyword">self</span>, default: U, f: F) <span class="punctuation">-&gt;</span> U</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>(T) <span class="punctuation">-&gt;</span> U,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Returns the provided default result (if none), or applies a function to the contained value (if any).</p>
<p>Arguments passed to <code>map_or</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or_else"><code>map_or_else</code></a>, which is lazily evaluated.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(x.<span class="title function_ invoke__">map_or</span>(<span class="number">42</span>, |v| v.<span class="title function_ invoke__">len</span>()), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; = <span class="literal">None</span>;</span><br><span class="line"><span class="built_in">assert_eq!</span>(x.<span class="title function_ invoke__">map_or</span>(<span class="number">42</span>, |v| v.<span class="title function_ invoke__">len</span>()), <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>为避免此处所有权的转移，我们可以使用<code>as_ref()</code>得到一个<strong>引用</strong>. 即<code>self.left.as_ref().map_or(false, |left| left.search(value))</code>.</p>
<p>另外，我们考虑使用<code>as_mut()</code> 方法，它能够从 <code>Option&lt;T&gt;</code> 生成一个 <code>Option&lt;&amp;mut T&gt;</code>，提供对其内部值的可变引用。这使得我们可以修改内部的值（例如，树节点的值）而不移动所有权。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(left) = <span class="keyword">self</span>.left.<span class="title function_ invoke__">as_mut</span>() &#123;</span><br><span class="line">    left.<span class="title function_ invoke__">insert</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>alogorithm5和algorithm6主要是要熟悉<code>VecDeque</code>和<code>HashSet</code>的API.</p>
<p>algorithm7自带的代码实现了迭代器的特性，可能我实现地有问题，我没有用到迭代器，就利用入栈、出栈与模式匹配就完成了这个练习.</p>
<h4 id="2024-10-14"><a href="#2024-10-14" class="headerlink" title="2024&#x2F;10&#x2F;14"></a>2024&#x2F;10&#x2F;14</h4><p>algorithm8是用队列模拟栈. 这里有一个比较好的思路是，始终将q1当作栈. 具体而言，就是让每次入栈的元素都成为q1的队首元素. 这通过依次出队原先的q1元素并使其入队q2而得.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, elem: T) &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="keyword">self</span>.q2.<span class="title function_ invoke__">enqueue</span>(elem);</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(e) = <span class="keyword">self</span>.q1.<span class="title function_ invoke__">dequeue</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.q2.<span class="title function_ invoke__">enqueue</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    std::mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.q1, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.q2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>algorithm9可以说是很不会了. 这里借鉴了很多，有空再完善这部分的笔记.</p>
<p>algorithm10这里我就实现了<code>add_edge()</code>. 感觉对Rust的std很不熟悉，其中使用<code>entry()</code>获取对应的Hash值，这个返回的结果可以被<code>or_insert_with()</code>处理，若不存在对应键则会自动插入；<code>or_insert_with()</code>会返回对应键值(<code>-&gt; V</code>)的可变引用.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.adjacency_table.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(node1))</span><br><span class="line">    .<span class="title function_ invoke__">or_insert_with</span>(<span class="type">Vec</span>::new)</span><br><span class="line">    .<span class="title function_ invoke__">push</span>((<span class="type">String</span>::<span class="title function_ invoke__">from</span>(node2), weight));</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rCore-1 ch1~3</title>
    <url>/2024/10/21/OS%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<blockquote>
<p>文档建设中…</p>
</blockquote>
<h2 id="ch1-基本环境"><a href="#ch1-基本环境" class="headerlink" title="ch1 基本环境"></a>ch1 基本环境</h2><h3 id="用户态执行环境"><a href="#用户态执行环境" class="headerlink" title="用户态执行环境"></a>用户态执行环境</h3><p>我们发现Rust编译器要找的入口函数是 <code>_start()</code> ，于是我们可以在 <code>main.rs</code> 中添加如下内容.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 target/riscv64gc-unknown-none-elf/debug/os</span></span><br><span class="line">  段错误 (核心已转储)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>出错了，这是因为目前的执行环境还缺了一个退出机制。实现如下. 在<a href="#syscall">第二章</a>会详细讲解.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"><span class="meta">#![feature(llvm_asm)]</span></span><br><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>: <span class="type">isize</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        llvm_asm!(<span class="string">&quot;ecall&quot;</span></span><br><span class="line">            : <span class="string">&quot;=&#123;x10&#125;&quot;</span> (ret)</span><br><span class="line">            : <span class="string">&quot;&#123;x10&#125;&quot;</span> (args[<span class="number">0</span>]), <span class="string">&quot;&#123;x11&#125;&quot;</span> (args[<span class="number">1</span>]), <span class="string">&quot;&#123;x12&#125;&quot;</span> (args[<span class="number">2</span>]), <span class="string">&quot;&#123;x17&#125;&quot;</span> (id)</span><br><span class="line">            : <span class="string">&quot;memory&quot;</span></span><br><span class="line">            : <span class="string">&quot;volatile&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_EXIT, [xstate <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">sys_exit</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即可使用.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build --target riscv64gc-unknown-none-elf</span></span><br><span class="line">  Compiling os v0.1.0 (/media/chyyuu/ca8c7ba6-51b7-41fc-8430-e29e31e5328f/thecode/rust/os_kernel_lab/os)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.26s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">?表示执行程序的退出码，它会被告知 OS]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 target/riscv64gc-unknown-none-elf/debug/os; <span class="built_in">echo</span> $?</span></span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>我们也可通过格式化宏与<code>sys_write</code>实现<code>println!</code>.</p>
<h3 id="裸机启动过程与关机"><a href="#裸机启动过程与关机" class="headerlink" title="裸机启动过程与关机"></a>裸机启动过程与关机</h3><p>我们通过QEMU模拟CPU加电的执行过程：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># os/Makefile</span></span><br><span class="line"><span class="section">run-inner: build</span></span><br><span class="line">	@qemu-system-riscv64 \</span><br><span class="line">		-machine virt \</span><br><span class="line">		-nographic \</span><br><span class="line">		-bios <span class="variable">$(BOOTLOADER)</span> \</span><br><span class="line">		-device loader,file=<span class="variable">$(KERNEL_BIN)</span>,addr=<span class="variable">$(KERNEL_ENTRY_PA)</span></span><br></pre></td></tr></table></figure>

<p>其中<code>-bios $(BOOTLOADER)</code> 在硬件内存中的固定位置 <code>0x80000000</code> 处放置了一个 BootLoader 程序 RustSBI. <code>-device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA)</code> 这个参数表示硬件内存中的特定位置 <code>$(KERNEL_ENTRY_PA)</code> 放置了操作系统的二进制代码 <code>$(KERNEL_BIN)</code> , <code>$(KERNEL_ENTRY_PA)</code> 的值是 <code>0x80200000</code> .</p>
<p>当我们执行包含上次参数的 qemu-system-riscv64 软件，就意味给这台虚拟的 RISC-V64 计算机加电了。此时，CPU的其它通用寄存器清零， 而PC寄存器会指向 <code>0x1000</code> 的位置，即 CPU 加电后执行的第一条指令的位置（固化在硬件中的一小段引导代码），它会很快跳转到 <code>0x80000000</code> 处， 即 RustSBI 的第一条指令. </p>
<p>RustSBI 完成基本的硬件初始化后， 会跳转操作系统的二进制代码 <code>$(KERNEL_BIN)</code> 所在内存位置 <code>0x80200000</code> ，执行操作系统的第一条指令。 这时我们的编写的操作系统才开始正式工作。</p>
<p>其中， <code>0x80000000</code> 是QEMU的硬件模拟代码中设定好的 <code>Bootloader</code> 的起始地址，<code>0x80200000</code> 是 <code>Bootloader--RustSBI</code> 的代码中设定好的 <code>os</code> 的<strong>起始地址</strong>。</p>
<blockquote>
<p>SBI 是 RISC-V 的一种底层规范，操作系统内核可直接调用SBI提供的底层功能，如关机、显示字符串等。</p>
</blockquote>
<hr>
<p>应用程序访问操作系统提供的系统调用的指令是 <code>ecall</code> ，操作系统访问 <strong>RustSBI</strong> 提供的SBI服务的SBI调用的指令也是 <code>ecall</code> . RustSBI 位于完全掌控机器的机器特权级（Machine Mode），通过 <code>ecall</code> 指令，可以完成从弱特权级到强特权级的转换。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/sbi.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sbi_call</span>(which: <span class="type">usize</span>, arg0: <span class="type">usize</span>, arg1: <span class="type">usize</span>, arg2: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        llvm_asm!(<span class="string">&quot;ecall&quot;</span></span><br><span class="line">            : <span class="string">&quot;=&#123;x10&#125;&quot;</span> (ret)</span><br><span class="line">            : <span class="string">&quot;&#123;x10&#125;&quot;</span> (arg0), <span class="string">&quot;&#123;x11&#125;&quot;</span> (arg1), <span class="string">&quot;&#123;x12&#125;&quot;</span> (arg2), <span class="string">&quot;&#123;x17&#125;&quot;</span> (which)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"><span class="keyword">const</span> SBI_SHUTDOWN: <span class="type">usize</span> = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">shutdown</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">sbi_call</span>(SBI_SHUTDOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;It should shutdown!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译生成ELF格式的执行文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build --release</span></span><br><span class="line"> Compiling os v0.1.0 (/media/chyyuu/ca8c7ba6-51b7-41fc-8430-e29e31e5328f/thecode/rust/os_kernel_lab/os)</span><br><span class="line">  Finished release [optimized] target(s) in 0.15s</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把ELF执行文件转成bianary文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --binary-architecture=riscv64 target/riscv64gc-unknown-none-elf/release/os --strip-all -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载运行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 -machine virt -nographic -bios ../bootloader/rustsbi-qemu.bin -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">无法退出，风扇狂转，感觉碰到死循环</span></span><br></pre></td></tr></table></figure>

<p>对 <code>os</code> ELF执行程序，通过rust-readobj分析，看到的入口地址不是 RustSBI 约定的 <code>0x80200000</code> 。我们需要修改 <code>os</code> ELF执行程序的内存布局。</p>
<h3 id="链接脚本-linker-ld-配置内存布局"><a href="#链接脚本-linker-ld-配置内存布局" class="headerlink" title="链接脚本 linker.ld 配置内存布局"></a>链接脚本 linker.ld 配置内存布局</h3><p>我们可以通过 <strong>链接脚本</strong> (Linker Script) 调整链接器的行为，使得最终生成的可执行文件的内存布局符合我们的预期。 我们修改 Cargo 的配置文件来使用我们自己的链接脚本 <code>os/src/linker.ld</code> 而非使用默认的内存布局.</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># os/.cargo/config.toml</span></span><br><span class="line"><span class="section">[build]</span></span><br><span class="line"><span class="attr">target</span> = <span class="string">&quot;riscv64gc-unknown-none-elf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[target.riscv64gc-unknown-none-elf]</span></span><br><span class="line"><span class="attr">rustflags</span> = [</span><br><span class="line">    <span class="string">&quot;-Clink-arg=-Tsrc/linker.ld&quot;</span>, <span class="string">&quot;-Cforce-frame-pointers=yes&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>具体的链接脚本 <code>os/src/linker.ld</code> 如下.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">BASE_ADDRESS = 0x80200000;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    skernel = .;</span><br><span class="line"></span><br><span class="line">    stext = .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    etext = .;</span><br><span class="line">    srodata = .;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    erodata = .;</span><br><span class="line">    sdata = .;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    edata = .;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss.stack)</span><br><span class="line">        sbss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    ebss = .;</span><br><span class="line">    ekernel = .;</span><br><span class="line"></span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 1 行我们设置了目标平台为 riscv ；第 2 行我们设置了整个程序的入口点为之前定义的全局符号 <code>_start</code>； 第 3 行定义了一个常量 <code>BASE_ADDRESS</code> 为 <code>0x80200000</code>.</p>
<p>第 5 行，<code>.</code> 表示当前地址，链接器会从它指向的位置开始，往下放置，从输入的目标文件中，收集来的段。我们可以对 <code>.</code> 进行赋值来调整接下来的段放在哪里，也可以创建一些全局符号赋值为 <code>.</code> 从而记录这一时刻的位置。</p>
<p>第 32 行，段 <code>.bss.stack</code> 被放入到可执行文件中的 <code>.bss</code> 段中的低地址中。在后面虽然有一个通配符 <code>.bss.*</code> ，但是由于链接脚本的优先匹配规则它并不会被匹配到后面去。 即<strong>地址区间 [sbss,ebss) 并不包括栈空间</strong>。</p>
<p>对于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata : &#123;</span><br><span class="line">    *(.rodata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒号前面表示最终生成的可执行文件的一个段的名字，花括号内按照放置顺序将所有输入目标文件的哪些段放在这个段中。每一行格式为 <code>&lt;ObjectFile&gt;(SectionName)</code>，表示目标文件 <code>ObjectFile</code> 的名为 <code>SectionName</code> 的段需要被放进去。我们也可以使用通配符。</p>
<p>因此，最终的合并结果是，在最终可执行文件 中各个常见的段 <code>.text, .rodata .data, .bss</code> 从低地址到高地址按顺序放置，每个段里面都包括了所有输入目标文件的同名段， 且每个段都有两个全局符号给出了它的开始和结束地址（比如 <code>.text</code> 段的开始和结束地址分别是 <code>stext</code> 和 <code>etext</code> ）.</p>
<p><code>ALIGN</code> 用于实现地址对齐，了解可见 <a href="https://www.bilibili.com/video/BV1aV4y1y7Sd/">到底为什么要内存对齐？</a></p>
<p>对链接脚本可以查询<a href="https://www.cnblogs.com/jianhua1992/p/16852784.html">链接脚本(Linker Scripts)语法和规则解析(自官方手册) - BSP-路人甲 - 博客园</a>.</p>
<blockquote>
<p>Q: 如何做到执行环境的初始化代码被放在内存上以 <code>0x80200000</code> 开头的区域上？</p>
<p>A: 从<code>0x80200000</code>开始，第一个被放置的 是 <code>.text</code> ，而里面第一个被放置的又是来自 <code>entry.asm</code> 中的段 <code>.text.entry</code>，这个段恰恰是含有两条指令的执行环境初始化代码， 它在所有段中最早被放置在我们期望的 <code>0x80200000</code> 处.</p>
</blockquote>
<h3 id="汇编配置栈空间布局"><a href="#汇编配置栈空间布局" class="headerlink" title="汇编配置栈空间布局"></a>汇编配置栈空间布局</h3><p>因为我们还没有设置栈空间，所以我们的程序还不足以运行。我们需要有一段代码来分配并栈空间，并把 <code>sp</code> 寄存器指向栈空间的起始位置。注意，栈空间是从上向下 <code>push</code> 数据的。</p>
<img src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012215.png" alt="栈空间" style="zoom:67%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># os/src/entry.asm</span><br><span class="line">	.section .text.entry</span><br><span class="line">    .globl _start</span><br><span class="line">_start:</span><br><span class="line">    la sp, boot_stack_top</span><br><span class="line">    call rust_main</span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack_lower_bound</span><br><span class="line">boot_stack_lower_bound:</span><br><span class="line">    .space 4096 * 16</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:</span><br></pre></td></tr></table></figure>

<p>栈空间的栈顶地址被全局符号 <code>boot_stack_top</code> 标识，栈底则被全局符号 <code>boot_stack</code> 标识.</p>
<p>汇编语言的快速入门可看 <a href="https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">汇编语言入门教程 - 阮一峰的网络日志</a>. 对<code>.section</code>和<code>.text</code>有<a href="https://blog.csdn.net/a513247209/article/details/118326530">汇编.section和.text以及入口地址解释_section .data-CSDN博客</a>. <code>la</code>即为 load address，是一条伪指令 <a href="https://blog.csdn.net/bird67/article/details/1920692">伪指令及其作用_xdata伪指令的作用-CSDN博客</a>.</p>
<p>然后我们可在<code>main.rs</code>中嵌入汇编代码.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="meta">#![feature(global_asm)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们手动设置 <code>global_asm</code> 特性来支持在 Rust 代码中嵌入全局汇编代码。首先通过 <code>include_str!</code> 宏将同目录下的汇编代码 <code>entry.asm</code> 转化为字符串并通过 <code>global_asm!</code> 宏嵌入到代码中。并且，需要通过宏将 <code>rust_main</code> 标记为 <code>#[no_mangle]</code> 以避免编译器对它的名字进行混淆，避免 <code>entry.asm</code> 找不到 <code>main.rs</code> 提供的外部符号 <code>rust_main</code> 从而导致链接失败。</p>
<h3 id="清空-bss-段"><a href="#清空-bss-段" class="headerlink" title="清空 .bss 段"></a>清空 .bss 段</h3><p>一般的应用程序的 <code>.bss</code> 段，在程序开始运行之前会被执环境（系统库或操作系统内核）固定初始化为零。在 ELF 文件中，为了节省磁盘空间，只会记录 <code>.bss</code> 段的位置。且应用程序的假定在它执行前，其 <code>.bss</code>段 的数据内容都已全是0.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">clear_bss</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sbss</span>();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ebss</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    (sbss <span class="keyword">as</span> <span class="type">usize</span>..ebss <span class="keyword">as</span> <span class="type">usize</span>).for_each(|a| &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (a <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序内自己进行清零的时候，我们就不用去解析 ELF，而是通过链接脚本 <code>linker.ld</code> 中给出的全局符号 <code>sbss</code> 和 <code>ebss</code> 来确定 <code>.bss</code> 段的位置.</p>
<h3 id="裸机打印实现"><a href="#裸机打印实现" class="headerlink" title="裸机打印实现"></a>裸机打印实现</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SBI_CONSOLE_PUTCHAR: <span class="type">usize</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">console_putchar</span>(c: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SBI_CONSOLE_PUTCHAR, [c, <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="comment">//sys_write(STDOUT, s.as_bytes());</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">console_putchar</span>(c <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把操作系统调用改为SBI调用 <code>syscall(SBI_CONSOLE_PUTCHAR, ...)</code>.</p>
<h3 id="理解内存"><a href="#理解内存" class="headerlink" title="理解内存"></a>理解内存</h3><p>CPU 可以通过物理地址来<strong>逐字节</strong>访问物理内存中保存的数据，通常以 <code>0x80000000</code> 为起始内存地址.</p>
<h4 id="函数调用-jalr-与-ret"><a href="#函数调用-jalr-与-ret" class="headerlink" title="函数调用: jalr 与 ret"></a>函数调用: jalr 与 ret</h4><p>在调用函数时，不同于分支、循环等其他控制流结构，被调用函数返回时，需要跳转到一个<strong>运行时确定</strong>（确切地说是在函数调用发生的时候）的地址，而不是一个编译器固定下来的地址。</p>
<img src="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/function-call.png" alt="Function Call" style="zoom:67%;" />

<p>对此，指令集必须给用于函数调用的跳转指令一些额外的能力，而不只是单纯的跳转。在 RISC-V 架构上，有两条指令即符合这样的特征.</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>指令</th>
<th>指令功能</th>
</tr>
</thead>
<tbody><tr>
<td>跳转并链接</td>
<td>jal rd, imm</td>
<td>rd &lt;- pc + 4<br />pc &lt;- pc + imm</td>
</tr>
<tr>
<td>寄存器跳转并链接</td>
<td>jalr rd, imm(rs)</td>
<td>rd &lt;- pc + 4<br />pc &lt;- rs + imm</td>
</tr>
</tbody></table>
<blockquote>
<p>在大多数只与通用寄存器打交道的指令中， rs 表示 <strong>源寄存器</strong> (Source Register)， imm 表示 <strong>立即数</strong> (Immediate)， 是一个常数，二者构成了指令的输入部分；而 rd 表示 <strong>目标寄存器</strong> (Destination Register)，它是指令的输出部分。rs 和 rd 可以在 32 个通用寄存器 x0~x31 中选取。</p>
</blockquote>
<p>这两条指令除了设置 pc 寄存器完成跳转功能之外，还将当前跳转指令的下一条指令地址保存在 <code>rd</code> 寄存器中。在 RISC-V 架构中， 通常使用 <strong><code>ra</code> 寄存器</strong>（即 <code>x1</code> 寄存器）作为其中的 <code>rd</code> ，因此在函数返回的时候，只需跳转回 <code>ra</code> 所保存的地址即可。</p>
<p>函数返回时，我们常使用一条 <strong>伪指令</strong> (Pseudo Instruction) 跳转回调用之前的位置: <code>ret</code> . 它会被汇编器翻译为 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jalr x0, 0(x1)</span><br></pre></td></tr></table></figure>

<p>含义为<strong>跳转到寄存器 <code>ra</code> （即 <code>x1</code>）保存的物理地址</strong>，由于 <strong><code>x0</code> 是一个恒为 0 的寄存器</strong>，任何写入到 <code>x0</code> 的值都会被直接丢弃，在 <code>rd</code> 中，保存这一步被省略，即<strong>不需要保存返回地址</strong>。</p>
<p>进行函数调用的时候，我们通过 <code>jalr</code> 指令 保存返回地址并实现跳转；而在函数即将返回的时候，则通过 <code>ret</code> 指令跳转之前的下一条指令继续执行。这<strong>两条指令</strong>实现了函数调用流程的核心机制。</p>
<h4 id="函数调用上下文与调用规范"><a href="#函数调用上下文与调用规范" class="headerlink" title="函数调用上下文与调用规范"></a>函数调用上下文与调用规范</h4><p>编译器除了函数调用的相关指令之外，基本不使用 <code>ra</code> 寄存器。意即，如果在函数中没有调用其他函数，那 ra 的值不会变化，函数调用流程能正常工作。但是，实际编写代码时，我们常常会遇到函数<strong>多层嵌套调用</strong>的情形。</p>
<p>因此我们需要保证，在一个函数调用子函数的前后，包括 <code>ra</code> 寄存器在内的所有通用寄存器的值都不能发生变化。 我们将由于函数调用，在控制流转移前后需要保持不变的<strong>寄存器集合</strong>称之为<strong>函数调用上下文</strong>(Context) 或称<strong>活动记录</strong> (Activation Record).</p>
<p>在调用子函数之前，我们需要在 内存中的一个区域保存(Save)函数调用上下文中的寄存器；而之后我们会从内存中同样的区域读取并恢复(Restore)函数调用上下文中的寄存器。</p>
<p>函数调用上下文中的寄存器被分为如下两类：</p>
<ul>
<li><strong>被调用者保存</strong> (Callee-Saved) 寄存器，即被调用的函数保证调用它前后，这些寄存器保持不变；</li>
<li><strong>调用者保存</strong> (Caller-Saved) 寄存器，被调用的函数可能会覆盖这些寄存器。</li>
</ul>
<p>寄存器可见于<a href="https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf">RISC-V 架构的 C 语言调用规范</a>或<a href="http://www.cs.cornell.edu/courses/cs3410/2019sp/schedule/slides/10-calling-notes-bw.pdf">Cornell</a>.</p>
<p>函数调用上下文由调用者和被调用者分别保存，其具体过程分别如下：</p>
<ul>
<li>调用者：首先保存不希望在函数调用过程中发生变化的调用者保存寄存器，然后通过 jal&#x2F;jalr 指令调用子函数，返回回来之后恢复这些寄存器。</li>
<li>被调用者：在函数开头保存函数执行过程中被用到的被调用者保存寄存器，然后执行函数，在退出之前恢复这些寄存器。</li>
</ul>
<p>无论是调用者还是被调用者，都会因调用行为而需要两段匹配的保存和恢复寄存器的汇编代码，可以分别将其称为 <strong>开场白</strong> (Prologue) 和 <strong>收场白</strong> (Epilogue)，它们会由编译器帮我们自动插入。</p>
<h4 id="栈指针与栈帧"><a href="#栈指针与栈帧" class="headerlink" title="栈指针与栈帧"></a>栈指针与栈帧</h4><p>函数调用上下文的保存&#x2F;恢复的寄存器保存在栈(Stack)中 . <code> sp</code>(即<code>x2</code>寄存器) 用来保存<strong>栈指针</strong> (Stack Pointer)，它是一个指向了内存中<strong>已经用过的位置</strong>的一个地址。</p>
<p>在 RISC-V 架构中，栈是从高地址到低地址增长的。在一个函数中，作为起始的<strong>开场白</strong>负责分配一块新的栈空间，其实它只需要知道需要空间的大小，然后将 <code>sp</code> 的值减小相应的字节数即可，于是物理地址区间 [新sp,旧sp) 对应的物理内存便可以被用于，函数调用上下文的保存&#x2F;恢复等，这块物理内存被称为这个函数的<strong>栈帧</strong> (Stackframe).</p>
<p>同理，函数中作为结尾的<strong>收场白</strong>负责将开场白分配的栈帧回收，这也仅仅需要 将 <code>sp</code> 的值增加相同的字节数回到分配之前的状态。这也可以解释为什么 <code>sp</code> 是一个<strong>被调用者保存寄存器</strong>。</p>
<p>函数调用过程中，栈帧分配与<code>sp</code>寄存器变化如图：</p>
<img src="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/CallStack.png" alt= "栈指针" style="zoom:33%;" />

<p>一个函数的栈帧内容可能如下.</p>
<img src="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/StackFrame.png" alt="StackFrame" style="zoom:67%;" />

<p>它的开头和结尾分别在 <code>sp(x2)</code> 和 <code>fp(s0)</code> 所指向的地址。按照地址从高到低分别有以下内容，它们都是通过 <code>sp</code> 加上一个偏移量来访问的：</p>
<ul>
<li><code>ra</code> 寄存器保存其返回之后的跳转地址，是一个调用者保存寄存器；</li>
<li>父亲栈帧的结束地址 <code>fp</code>，是一个被调用者保存寄存器；</li>
<li>其他被调用者保存寄存器 <code>s1</code>~&#96;s11&#96;；</li>
<li>函数所使用到的局部变量。</li>
</ul>
<p>因此，栈上实际上保存了一条完整的函数调用链，通过适当的方式我们可以实现对它的跟踪。</p>
<h4 id="程序内存布局"><a href="#程序内存布局" class="headerlink" title="程序内存布局"></a>程序内存布局</h4><p>当我们将源代码编译为可执行文件之后，会得到一个看似充满杂乱无章字节的文件。这些字节至少可以分成代码和数据两部分，代码部分由一条条可以被 CPU 解码并执行的指令组成，而数据部分只被 CPU 视作可用的存储空间。</p>
<p>我们还可根据其功能，进一步把两个部分划分为更小的单位： <strong>段</strong> (Section) . 不同的段会被编译器放置在内存不同的位置上，这构成了程序的 <strong>内存布局</strong> (Memory Layout)。一种典型的程序相对内存布局如下：</p>
<img src="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/MemoryLayout.png" alt="内存布局" style="zoom:33%;" />

<p>代码部分只有代码段 <code>.text</code> 一个段，存放程序的所有汇编代码。</p>
<p>数据部分则还可以继续细化：</p>
<ul>
<li>已初始化数据段保存程序中那些已初始化的全局数据，分为 <code>.rodata</code> 和 <code>.data</code> 两部分。前者存放只读的全局数据，通常是常数或常量字符串等；而后者存放可修改的全局数据。</li>
<li>未初始化数据段 <code>.bss</code> 保存程序中那些未初始化的全局数据，通常由程序的加载者代为进行零初始化，也即将这块区域逐字节清零；</li>
<li><strong>堆</strong> (heap) 区域用来存放程序运行时动态分配的数据，如 C&#x2F;C++ 中的 <code>malloc</code>&#x2F;<code>new</code> 分配到的数据本体就放在堆区域，它向高地址增长；</li>
<li>栈区域 stack 不仅用作函数调用上下文的保存与恢复，每个函数作用域内的局部变量也被编译器放在它的栈帧内。它向低地址增长。</li>
</ul>
<p>对于堆上的动态变量，其本体被保存在堆上，大小在<strong>运行时</strong>才能确定。而我们只能直接访问栈上或者全局数据段中的<strong>编译期确定大小</strong>的变量。 因此，我们需要通过一个（运行时分配内存得到的）指向堆上数据的指针来访问它。指针的位宽确实在编译期就能够确定。该指针即可以作为局部变量放在栈帧内，也可以作为全局变量放在全局数据段中。</p>
<h2 id="ch2-批处理系统"><a href="#ch2-批处理系统" class="headerlink" title="ch2 批处理系统"></a>ch2 批处理系统</h2><p>chap2实现应用程序一部分，在OS启动时执行了<code>clear_bss()</code>函数，关于BSS的功能，参考<a href="https://blog.csdn.net/sgc_bf/article/details/101227860">静态存储区（Bss、数据段、代码段），堆，栈-CSDN博客</a>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="meta">#[link_section = <span class="string">&quot;.text.entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">main</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>lib.rs</code>中定义一个<code>main</code>函数，其具有弱链接特性。在编译过程中，弱符号遇到强符号时，会选择强符号而丢掉弱符号。参考<a href="https://zhuanlan.zhihu.com/p/55768978">嵌入式C语言自我修养 09：链接过程中的强符号和弱符号 - 知乎</a>.</p>
<p>故rCore文档中说：</p>
<blockquote>
<p>我们使用 Rust 宏将其标志为弱链接。这样在最后链接的时候， 虽然 <code>lib.rs</code> 和 <code>bin</code> 目录下的某个应用程序中都有 <code>main</code> 符号， 但由于 <code>lib.rs</code> 中的 <code>main</code> 符号是弱链接， 链接器会使用 <code>bin</code> 目录下的函数作为 <code>main</code> 。 如果在 <code>bin</code> 目录下找不到任何 <code>main</code> ，那么编译也能通过，但会在运行时报错。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![feature(linkage)]</span>    <span class="comment">// 启用弱链接特性</span></span><br><span class="line"><span class="meta">#[linkage = <span class="string">&quot;weak&quot;</span>]</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Cannot find main!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="syscall"></a><br>在系统调用时，我们需要将对应的参数储存在寄存器中，我们需要了解RISC-V架构中寄存器的相关知识<a href="https://blog.csdn.net/weixin_42031299/article/details/132839814">RISV-V架构的寄存器介绍_riscv寄存器-CSDN博客</a>.</p>
<p>这里使用了Rust的内联汇编宏<code>asm!</code>，参考<a href="https://doc.rust-lang.org/nightly/reference/inline-assembly.html">Inline assembly - The Rust Reference</a>. 由于Rust 编译器无法判定汇编代码的安全性，所以我们需要将其包裹在 unsafe 块中.</p>
<p>简而言之，这条汇编代码的执行结果是以寄存器 <code>a0~a2</code> 来保存系统调用的参数，以及寄存器 <code>a7</code> 保存 syscall ID， 返回值通过寄存器 <code>a0</code> 传递给局部变量 <code>ret</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>: <span class="type">isize</span>;</span><br><span class="line">   <span class="keyword">unsafe</span> &#123;</span><br><span class="line">       core::arch::asm!(</span><br><span class="line">           <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">           <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">           <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">           <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">           <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br><span class="line">   ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 <code>inlateout(&quot;x10&quot;) args[0] =&gt; ret</code>：</p>
<ul>
<li><strong>传值</strong>：<code>args[0]</code> 是输入值，它会在调用 <code>ecall</code> 之前被加载到 <code>x10</code> 寄存器。</li>
<li><strong>返回结果</strong>：执行完 <code>ecall</code> 后，<code>x10</code> 的值变为结果值，并把这个结果存入变量 <code>ret</code>。</li>
</ul>
<p>于是我们基于<code>syscall</code>就可以实现一些基本的系统功能：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SYSCALL_WRITE: <span class="type">usize</span> = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buffer: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_WRITE, [fd, buffer.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, buffer.<span class="title function_ invoke__">len</span>()])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_EXIT, [xstate <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装，有</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"><span class="keyword">use</span> syscall::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(fd: <span class="type">usize</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123; <span class="title function_ invoke__">sys_write</span>(fd, buf) &#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit</span>(exit_code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123; <span class="title function_ invoke__">sys_exit</span>(exit_code) &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>chap2实现批处理操作系统一部分，对<code>link_app.S</code>的汇编代码，可以理解为<code>_num_app</code>这一全局符号指向了一个数组，一个表示应用程序数量，三个表示每个应用程序的开始地址，一个表示最后一个应用程序的结束地址。</p>
<p>汇编中的常用伪指令：</p>
<p><strong><code>.section</code></strong>:</p>
<ul>
<li>指定接下来的代码或数据属于哪一节（段）。常见的数据段有 <code>.text</code>（代码段）、<code>.data</code>（数据段）、<code>.bss</code>（未初始化数据段）等。</li>
</ul>
<p><strong><code>.align</code></strong>:</p>
<ul>
<li>用于指定数据的对齐。譬如，<code>.align 3</code> 会将接下来的数据对齐到 2^3&#x3D;8 字节的边界。</li>
</ul>
<p><strong><code>.global</code></strong> 或 <strong><code>.globl</code></strong>:</p>
<ul>
<li>用于声明符号为全局符号，使其在其他文件中可见。</li>
</ul>
<p><strong><code>.quad</code></strong>:</p>
<ul>
<li>用于分配并初始化一个 64-bit（8字节）数据。类似的指令有 <code>.byte</code>、<code>.word</code>、<code>.long</code> 等，用于分配其他大小的数据。</li>
</ul>
<p><strong><code>.incbin</code></strong>:</p>
<ul>
<li>包含一个外部二进制文件的内容，并将其嵌入到当前字节流中。这在需要将预编译的二进制文件直接打包到程序中的情况下非常有用。</li>
</ul>
<p>在初始化<code>AppManager</code>的代码中，<code>UPSafeCell</code>获取内部对象的可变引用，拥有内部可变性。<code>lazy_static!</code> 宏提供了全局变量的运行时初始化功能。对于有些全局变量，其初始化依赖于运行期间才能得到的数据。 此处声明了一个 <code>AppManager</code> 结构的名为 <code>APP_MANAGER</code> 的全局实例， 只有在它第一次被使用到的时候才会进行实际的初始化工作。</p>
<p>CPU的L1 Cache分为数据缓存(d-cache)和指令缓存(i-cache)，二者的大概介绍<a href="https://blog.csdn.net/chenhuanqiangnihao/article/details/128312905">CPU一级缓存L1 D-cache\L1 I-cache-CSDN博客</a>. 二者分别用来存放，数据和执行这些数据的指令，而且两者可以同时被CPU访问，减少了争用Cache所造成的冲突，提高了CPU效能。代码中我们使用汇编指令 <code>fence.i</code> 清理 i-cache.</p>
<h4 id="2024-10-22"><a href="#2024-10-22" class="headerlink" title="2024&#x2F;10&#x2F;22"></a>2024&#x2F;10&#x2F;22</h4><p>在RISC-V体系架构中，异常和中断的过程被统称为trap。广义的来说，中断也属于异常的一部分；不管发生异常或是中断，微处理器的硬件行为是一致的，<strong>微处理器暂停当前程序，转向异常或中断处理程序，处理完成后返回之前暂停的程序。</strong></p>
<p>关于触发异常<code>Trap</code>的情况:</p>
<ol>
<li>其一是用户态软件为获得内核态操作系统的服务功能而执行特殊指令<ul>
<li>指令本身属于高特权级的指令，如 <code>sret</code> 指令(表示从 S 模式返回到 U 模式)</li>
<li>指令访问了 <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/4trap-handling.html#term-s-mod-csr">S模式特权级下才能访问的寄存器</a> 或内存，如表示S模式系统状态的 <strong>控制状态寄存器</strong> <code>sstatus</code> 等</li>
</ul>
</li>
<li>其二是在执行某条指令期间产生了错误（如执行了用户态不允许执行的指令或者其他错误）并被 CPU 检测到</li>
</ol>
<p>网上有一些博客对此有更详细的介绍：<a href="https://blog.csdn.net/weixin_53479532/article/details/136611555">RISC-V 32架构实践专题九（从零开始写操作系统-trap机制）_mtval寄存器-CSDN博客</a>, 与<a href="https://www.cnblogs.com/chenhan-winddevil/p/18327630">rCore学习笔记 018-实现特权级的切换 - winddevil - 博客园</a>. 在RISC-V Reader中也有关于CSR的描述.</p>
<blockquote>
<p>mtvec（Machine Trap Vector），存放发生异常时处理器跳转的地址（图 10.7）<br>mepc（Machine Exception PC），指向发生异常的指令（图 10.8）。</p>
<p>RISC-V Reader: Page.105</p>
</blockquote>
<p>用户程序与操作系统的操作各属于不同的特权级，在系统（程序）运行时就涉及到特权级之间的切换。我们使用CSR来保存M&#x2F;S特权的各种状态；而涉及到保存与还原各种状态的需求，我们就有了用户栈与内存栈的区分。</p>
<h4 id="2024-10-23"><a href="#2024-10-23" class="headerlink" title="2024&#x2F;10&#x2F;23"></a>2024&#x2F;10&#x2F;23</h4><p>对于<code>csrrw rd, csr, rs1</code>，作用是将来自寄存器 <code>rs1</code> 的值写入控制和状态寄存器（CSR），并将CSR的旧值读入寄存器 <code>rd</code>. 因此这里起到的是交换<code> sscratch</code> 和<code> sp</code> 的效果。在这一行之前 <code>sp</code> 指向用户栈， <code>sscratch</code> 指向内核栈，现在 <code>sp</code> 指向内核栈， <code>sscratch</code> 指向用户栈。</p>
<p><code>addi sp, sp, -34*8</code>用于预先分配栈帧（内核栈），将<code>sp</code>的值与<code>-34*8</code>相加后存入<code>sp</code>.</p>
<p><code>sd rs2, offset(rs1)</code>，<code>sd</code> 指令的目的是将 <code>rs2</code> 寄存器中的64位数据存入由 <code>rs1</code> 中的地址加上 <code>offset</code> 计算得到的内存地址. 按照 <code>TrapContext</code> 结构体的内存布局，基于内核栈的位置（sp所指地址）来从低地址到高地址分别按顺序放置 <code>x0</code>~&#96;x31<code>这些通用寄存器，最后是 sstatus 和 sepc .  通用寄存器 xn 应该被保存在地址区间 </code>[sp+8n,sp+8(n+1))&#96; . </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.macro SAVE_GP n</span><br><span class="line">    sd x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">sd x1, 1*8(sp)</span><br><span class="line"># skip sp(x2), we will save it later</span><br><span class="line">sd x3, 3*8(sp)</span><br><span class="line"># skip tp(x4), application does not use it</span><br><span class="line"># save x5~x31</span><br><span class="line">.set n, 5</span><br><span class="line">.rept 27</span><br><span class="line">    SAVE_GP %n</span><br><span class="line">    .set n, n+1</span><br><span class="line">.endr</span><br></pre></td></tr></table></figure>

<p><code>__alltraps</code>和<code>__restore</code>作为对应操作，其思路完全相反.</p>
<p>Trap 处理的总体流程如下：首先通过 <code>__alltraps</code> <strong>将 Trap 上下文保存在内核栈上</strong>，然后跳转到使用 Rust 编写的 <code>trap_handler</code> 函数 完成 Trap 分发及处理。当 <code>trap_handler</code> 返回之后，使用 <code>__restore</code> 从保存在内核栈上的 Trap 上下文<strong>恢复寄存器</strong>。最后通过一条 <code>sret</code> 指令回到应用程序执行。</p>
<p>当批处理操作系统初始化完成，或者是某个应用程序运行结束或出错的时候，我们要调用 <code>run_next_app</code> 函数切换到下一个应用程序。类似地，当我们需要从S模式返回U模式时，我们也需要在内核栈上压入一个Trap上下文，之后通过<code>__restore</code>函数，让这些寄存器到达启动应用程序所需要的上下文状态。</p>
<hr>
<p>这里涉及到了特权切换的问题，整理一下，RISCV架构下有三种特权级别，分别是Machine、Supervisor和User，简称M模式、S模式和U模式。M模式权限最高，在这个级别下的程序可以访问一切硬件和执行所有特权指令；S模式一般用于运行操作系统，可以设置MMU使用虚拟地址；U模式一般是普通应用程序使用，权限最低。</p>
<p>在arm下的应用程序通过<code>swi</code>指令可以将处理器从低特权级别切换到高特权级别，一般像Linux下的系统调用都是通过这种方式来使用的。类似的，在RISCV中，通过<code>ecall</code>指令可以从低特权切换到高特权，在U模式下执行就切换到S模式，在S模式下调用就切换到M模式。另外在RISCV中，默认产生中断和异常时，处理器自动切换到M模式处理，可以通过中断托管设置将一些中断和异常直接交给S模式处理。</p>
<p>参见<a href="https://www.cnblogs.com/dream397/p/15687184.html">riscv 中断和异常处理 - tycoon3 - 博客园</a>.</p>
<h4 id="2024-10-24"><a href="#2024-10-24" class="headerlink" title="2024&#x2F;10&#x2F;24"></a>2024&#x2F;10&#x2F;24</h4><p>今天看到有人说rCore-v3的内容会更加详细，更好理解。翻了翻确实如此，竟然现在才知道。<em>我真傻，真的</em>。</p>
<p>先趁此复习一下ch2的内容：如果应用越过了硬件所设置特权级界限或主动申请获得操作系统的服务，就会触发 Trap 并进入到批处理系统中进行处理。可以看到，<strong>在内存中同一时间最多只需驻留一个应用</strong>。这是因为只有当一个应用出错或退出之后，批处理系统才会去将另一个应用加载到相同的一块内存区域。</p>
<p>对于多道程序的处理，发展出两种方式：</p>
<ul>
<li><p><strong>放弃处理器</strong>的操作算是一种对处理器资源的直接管理，所以应用程序可以发出这样的系统调用，让操作系统来具体完成。这样的操作系统就是支持 <strong>多道程序</strong> 协作式操作系统</p>
</li>
<li><p>把一个程序在一个时间片上占用处理器执行的过程称为一个 <strong>任务</strong> (Task)，让操作系统对不同程序的 <strong>任务</strong> 进行管理。通过平衡各个程序在整个时间段上的任务数，使一个包含多个时间片的时间段上，会有属于不同程序的多个任务在轮流占用处理器执行，这样的操作系统就是支持 <strong>分时多任务</strong> 的抢占式操作系统。</p>
</li>
</ul>
<p>在<code>load_apps()</code>中，第 <code>i</code>个应用被加载到以物理地址 <code>base_i</code> 开头的一段物理内存上，先清空<code>base_i</code>段的值，之后将<code>app_start[i]</code>的内容复制其上.</p>
<hr>
<p>我们将实现<strong>任务切换</strong>，任务切换支持的场景是：一个应用在运行途中便会主动交出 CPU 的使用权，此时它只能暂停执行，等到内核重新给它分配处理器资源之后才能恢复并继续执行。</p>
<p>我们就把应用程序的一个计算阶段的执行过程（也是一段执行流）称为一个 <strong>任务</strong> ，所有的任务都完成后，应用程序也就完成了。从一个程序的任务切换到另外一个程序的任务称为 <strong>任务切换</strong> 。为了确保切换后的任务能够正确继续执行，操作系统需要支持让任务的执行“暂停”和“继续”。</p>
<p>一旦一条执行流需要支持“暂停-继续”，就需要提供一种执行流切换的机制，而且需要保证执行流被切换出去之前和切换回来之后，它的状态，也就是在执行过程中同步变化的资源（如寄存器、栈等）需要<strong>保持不变</strong>，<strong>或者变化在它的预期之内</strong>。而不是所有的资源都需要被保存，事实上只有那些对于执行流接下来的进行仍然有用，且在它被切换出去的时候有被覆盖的风险的那些资源才有被保存的价值。这些物理资源被称为 <strong>任务上下文 (Task Context)</strong> 。</p>
<p>这里发现rCore-v3的手册写的很好，前面有些懵懂的概念都有详细的解释，应当往前翻看。</p>
<h4 id="2024-10-26"><a href="#2024-10-26" class="headerlink" title="2024&#x2F;10&#x2F;26"></a>2024&#x2F;10&#x2F;26</h4><p>于是开始重读rCore-v3.</p>
<h5 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h5><p>应用程序在执行过程中，如果出现外设中断或 CPU 异常，处理器执行的前一条指令和后一条指令会位于两个完全不同的位置，即不同的执行环境 。比如，前一条指令还在应用程序的代码段中，后一条指令就跑到操作系统的代码段中去了，这就是一种控制流的“突变”，即控制流脱离了其所在的执行环境，并产生 <a href="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/chapter0/3os-hw-abstract.html#term-ee-switch">执行环境的切换</a>。</p>
<p><strong>异常控制流</strong> (ECF, Exceptional Control Flow) 是处理器在执行过程中的突变，其主要作用是通过硬件和操作系统的协同工作来响应处理器状态中的特殊变化。比如当应用程序正在执行时，产生了时钟外设中断，导致操作系统打断当前应用程序的执行，转而进入 <strong>操作系统</strong> 所在的执行环境去处理时钟外设中断。处理完毕后，再回到应用程序的执行环境中被打断的地方继续执行。</p>
<h5 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h5><p>这里我们把控制流在执行完某指令时的物理资源内容，即确保下一时刻能继续 <em>正确</em> 执行控制流指令的物理资源内容称为控制流的 <strong>上下文</strong> (Context) ，也可称为控制流所在执行环境的状态。</p>
<p>这里需要理解控制流的上下文对控制流的 <em>正确</em> 执行的影响。如果在某时刻，由于某种有意或无意的原因，控制流的上下文发生了不是由于控制流本身的指令产生的变化，并使得控制流执行接下来的指令序列时出现了偏差，并最终导致执行过程或执行结果不符合预期，这种情形称为没有正确执行。 所以，我们这里说的控制流的上下文是指仅会影响控制流<strong>正确执行</strong>的有限的物理资源内容。</p>
<p>随着CPU的执行，各种前缀的上下文（执行环境的状态）会在不断的变化。</p>
<p>如果出现了处理器在执行过程中的突变（即异常控制流）或转移（如多层函数调用），需要由维持执行环境的软硬件协同起来，<strong>保存</strong>发生突变或转移前的当前的执行环境的状态（比如突变或函数调用前一刻的指令寄存器，栈寄存器和其他一些通用寄存器等内容），并在完成突变处理或被调用函数后，<strong>恢复</strong>突变或转移前的执行环境的状态。这是由于完成与突变相关的执行会破坏突变前的执行环境状态（比如上述各种寄存器的内容），导致如果不保存状态，就无法恢复到突变前执行环境，继续正常的普通控制流的执行。</p>
<p>对于异常控制流的上下文保存与恢复，主要是通过 CPU 和操作系统（手动编写在栈上保存与恢复寄存器的指令）来协同完成；对于函数转移控制流的上下文保存与恢复，主要是通过编译器（自动生成在栈上保存与恢复寄存器的指令）来帮助完成的。</p>
<p>在操作系统中，需要处理三类异常控制流：<strong>外设中断</strong> (Device Interrupt) 、<strong>陷入</strong> (Trap) 和<strong>异常</strong> (Exception，也称Fault Interrupt)。</p>
<blockquote>
<p>Q: 应用程序也有其上下文吗？</p>
<p>A: 如果一个控制流是属于某个应用程序的，那么这个控制流的上下文简称为应用程序上下文。</p>
</blockquote>
<p>从开始到结束的整个执行过程中，截取其中一个时间段，在这个时间段中，它所执行的指令流形成了这个时间段的控制流，而控制流中的每条执行的指令和它执行后的上下文，形成由二元组&lt;指令指针，上下文&gt;（&lt;pc，context&gt;）构成的有序序列，我们用 <strong>执行流</strong> (Execution Flow) 或 <strong>执行历史</strong> (Execution History) 来表示这个二元组有序序列。</p>
<ul>
<li>外设 <strong>中断</strong> (Interrupt) 由外部设备引起的外部 I&#x2F;O 事件如时钟中断、控制台中断等。外设中断是异步产生的，与处理器的执行无关。</li>
<li><strong>异常</strong> (Exception) 是在处理器执行指令期间检测到不正常的或非法的内部事件（如除零错、地址访问越界）。</li>
<li><strong>陷入</strong> (Trap) 是在程序中使用请求操作系统服务的系统调用而引发的有意事件。</li>
</ul>
<blockquote>
<p>在RISC-V的特权级规范文档中，“陷入” 包含中断和异常，而原来意义上的陷入(trap，系统调用)只是exception中的一种情况。另外还有一种 “软件中断” ，它是指软件可以通过写特定寄存器（mip&#x2F;sip）的特定位（MSIP&#x2F;SSIP&#x2F;USIP）来产生的中断。而异常和中断有严格的区分，在记录产生的异常或中断类型的特定寄存器（mcause&#x2F;scause）中，寄存器最高位为 <code>0</code> 表示异常，最高位为 <code>1</code> 表示中断。进一步的详细信息可以可参考RISC-V的特权级规范文档和后面的章节。</p>
</blockquote>
<h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>为了提高处理器的利用率，操作系统需要让处理器足够忙，即让不同的程序轮流占用处理器来运行。如果一个程序因某个事件而不能运行下去时，就通过进程上下文切换把处理器占用权转交给另一个可运行程序。进程上下文切换如下图所示：</p>
<img src="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/context-switch.png" alt="进程上下文切换" style="zoom:33%;" />

<p>一个进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 操作系统中的进程管理需要采用某种调度策略将处理器资源分配给程序并在适当的时候回收，并且要尽可能充分利用处理器的硬件资源。</p>
<hr>
<h4 id="ch3-多道程序与分时多任务"><a href="#ch3-多道程序与分时多任务" class="headerlink" title="ch3 多道程序与分时多任务"></a>ch3 多道程序与分时多任务</h4><p>与第二章相同，所有应用的 ELF 都经过 strip 丢掉所有 ELF header 和符号变为二进制镜像文件，随后以同样的格式通过 <code>link_user.S</code> 在编译的时候直接链接到内核的数据段中。不同的是，我们对相关模块进行了调整：在第二章中应用的加载和进度控制都交给 <code>batch</code> 子模块，而在第三章中我们将应用的加载这部分功能分离出来在 <code>loader</code> 子模块中实现，应用的执行和切换则交给 <code>task</code> 子模块。</p>
<p>关于ELF，可以参考<a href="https://blog.csdn.net/daide2012/article/details/73065204">ELF文件详解—初步认识_.elf-CSDN博客</a>.</p>
<p>但此处的任务切换与批处理的Trap切换有所不同，本节的任务切换的执行过程是第二章的 Trap 之后的另一种异常控制流，都是描述两条执行流之间的切换，如果将它和 Trap 切换进行比较，会有如下异同：</p>
<ul>
<li>与 Trap 切换不同，它不涉及特权级切换；</li>
<li>与 Trap 切换不同，它的一部分是由编译器帮忙完成的；</li>
<li>与 Trap 切换相同，它对应用是透明的。</li>
</ul>
<p>考虑 CPU 只能 <em>单方面</em> 通过读取外设提供的寄存器来获取外设请求处理的状态。多道程序的思想在于：内核同时管理多个应用。如果外设处理的时间足够长，那我们可以先进行任务切换去执行其他应用，在某次切换回来之后，应用再次读取设备寄存器，发现请求已经处理完毕了，那么就可以用拿到的完整的数据继续向下执行了。这样的话，只要同时存在的应用足够多，就能保证 CPU 不必浪费时间在等待外设上，而是几乎一直在进行计算。这种任务切换，是通过应用进行一个名为 <code>sys_yield</code> 的系统调用来实现的，这意味着它主动交出 CPU 的使用权给其他应用。</p>
<p>一个应用会持续运行下去，直到它主动调用 <code>sys_yield</code> 来交出 CPU 使用权。内核将很大的权力下放到应用，让所有的应用互相协作来最终达成最大化 CPU 利用率，充分利用计算资源这一终极目标。在计算机发展的早期，由于应用基本上都是一些简单的计算任务，且程序员都比较遵守规则，因此内核可以信赖应用，这样协作式的制度是没有问题的。</p>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/10/20/hello-world/</url>
    <content><![CDATA[<h2 id="第一部分-论神"><a href="#第一部分-论神" class="headerlink" title="第一部分 论神"></a>第一部分 论神</h2><h3 id="界说"><a href="#界说" class="headerlink" title="界说"></a>界说</h3><p>(一) 自因(causa sui)，我理解为这样的东西，它的本质(essentia)即包含存在(existentia)，或者它的本性只能设想为存在着。</p>
<p>(二) 凡是可以为同性质的另一事物所限制的东西，就叫做自类有限(insuo genere finita)。例如一个物体被称为有限，就是因为除了这个物体之外，我们常常可以设想另一个更大的物体。同样，一个思想可以为另一个思想所限制。但是物体不能限制思想，思想也不能限制物体。</p>
<p>(三) 实体(substantia)，我理解为在自身内并通过自身而被认识的东西。换言之，形成实体的概念，可以无须借助于他物的概念。</p>
<p>(四) 属性(attributus)，我理解为由知性(intellectus)看来是构成实体的 本质的东西。</p>
<p>(五) 样式(modus)，我理解为实体的分殊(affectiones)，亦即在他物内(inalio est)通过他物而被认知的东西(per alium concipitur)。</p>
<p>(六) 神(Deus)，我理解为绝对无限的存在，亦即具有无限“多”属性的实体，其中每一属性各表示永恒无限的本质。说明 我说神是绝对无限而不说它是自类无限(in suo genereinfinita)，因为仅仅是自类无限的东西，我们可以否认其无限多的属性；而绝对无限者的本性中就具备了一切足以表示本质的东西，却并不包含否定。</p>
<p>(七) 凡是仅仅由自身本性的必然性而存在、其行为仅仅由它自身决定的东西叫做自由(libera)。反之，凡一物的存在及其行为均按一定的方式为他物所决定，便叫做必然(necessaria，)或受制(coata)。</p>
<p>(八) 永恒(aeternitas)，我理解为存在的自身，就存在被理解为只能从永恒事物的界说中必然推出而言。</p>
<p><strong>说明</strong> 因为这样的存在也可以设想为永恒的真理，有如事物的本质，因此不可以用绵延或时间去解释它，虽说绵延可以设想为无始无终。</p>
]]></content>
  </entry>
  <entry>
    <title>rCore-2</title>
    <url>/2024/11/20/rCore-2/</url>
    <content><![CDATA[<h3 id="ch4-分页机制与地址空间"><a href="#ch4-分页机制与地址空间" class="headerlink" title="ch4 分页机制与地址空间"></a>ch4 分页机制与地址空间</h3><p>这个视频作了一个不错的概述: <a href="https://www.bilibili.com/video/BV1oi4y1T7RP/?share_source=copy_web&vd_source=7065d846d368bb90906c142c279a2832">【操作系统】内存管理——地址空间</a>.</p>
<p>用<code>satp</code>CSR的MODE字段来开启MMU.</p>
<img src="https://learningos.cn/rCore-Camp-Guide-2024A/_images/satp.png" alt="satp CSR" style="zoom:67%;" />

<h4 id="物理地址-虚拟地址-物理页面-物理页帧"><a href="#物理地址-虚拟地址-物理页面-物理页帧" class="headerlink" title="物理地址&#x2F;虚拟地址&#x2F;物理页面&#x2F;物理页帧"></a>物理地址&#x2F;虚拟地址&#x2F;物理页面&#x2F;物理页帧</h4><p>单个页面的大小设置为 4KiB(<code>PAGE_SIZE</code>) ，每个虚拟页面和物理页帧都按 4 KB 对齐。 4KiB 需要用 12 位字节地址来表示，构成低 12 位即 <strong>页内偏移</strong> (Page Offset) 。</p>
<p>虚拟地址的高 27 位，即 [38:12] 为它的虚拟页号 VPN； 物理地址的高 44 位，即 [55:12] 为它的物理页号 PPN。页号可以用来定位一个虚拟&#x2F;物理地址属于哪一个虚拟页面&#x2F;<strong>物理页帧</strong>。</p>
<img src="https://learningos.cn/rCore-Camp-Guide-2024A/_images/sv39-va-pa.png" alt="Address" style="zoom:67%;" />

<p>于是对地址类型，有取页内偏移量的操作<code>page_offset</code>，用二进制与运算实现；取页码<code>PPN</code>用二进制除法实现取<code>PhysAddr</code>的高位：</p>
<span id="more"></span>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/address.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PhysAddr</span> &#123;</span><br><span class="line">    <span class="comment">/// Get the (floor) physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">floor</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123;</span><br><span class="line">        <span class="title function_ invoke__">PhysPageNum</span>(<span class="keyword">self</span>.<span class="number">0</span> / PAGE_SIZE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Get the page offset of physical address</span></span><br><span class="line">    <span class="comment">//  pub const PAGE_SIZE: usize = 4096 (0x1000) = ..1_0000_0000_0000</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">page_offset</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span> &amp; (PAGE_SIZE - <span class="number">1</span>) <span class="comment">// 1111_1111_1111</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PhysAddr -&gt; PhysPageNum</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;PhysAddr&gt; <span class="keyword">for</span> <span class="title class_">PhysPageNum</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(v: PhysAddr) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">page_offset</span>(), <span class="number">0</span>);</span><br><span class="line">        v.<span class="title function_ invoke__">floor</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PhysPageNum -&gt; PhysAddr</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;PhysPageNum&gt; <span class="keyword">for</span> <span class="title class_">PhysAddr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(v: PhysPageNum) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Self</span>(v.<span class="number">0</span> &lt;&lt; PAGE_SIZE_BITS)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>地址转换是以页为单位进行的，<strong>转换前后地址页内偏移部分不变</strong>。MMU 只是从虚拟地址中取出 27 位虚拟页号， 在页表中查到其对应的物理页号，如果找到，就将得到的 44 位的物理页号与 12 位页内偏移拼接到一起，形成 56 位物理地址。</p>
<h4 id="页表项PTE"><a href="#页表项PTE" class="headerlink" title="页表项PTE"></a>页表项PTE</h4><p>在页表中以虚拟页号作为索引不仅能够查到物理页号，还能查到一组保护位，它控制了应用对地址空间每个虚拟页面的访问权限。但实际上还有更多的标志位，物理页号和全部的标志位以某种固定的格式保存在一个结构体中，它被称为 <strong>页表项</strong> (PTE, Page Table Entry) ，是利用虚拟页号在页表中查到的结果。低位8位标志位<code>PTEFlags</code>具体可见<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html#id5">SV39 多级页表的硬件机制 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</a>.</p>
<img src="https://learningos.cn/rCore-Camp-Guide-2024A/_images/sv39-pte.png" alt="PTE" style="zoom:67%;" />

<p><code>ppn</code>函数将<code>PTE</code>的PPN部分与0xFFFFFFFFFFF（十六进制形式的 44 个 1）取与，将得到的结果用<code>into()</code>进行转换位<code>PhysPageNum</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"><span class="comment">/// page table entry structure</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PageTableEntry</span> &#123;</span><br><span class="line">    <span class="comment">/// bits of page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> bits: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTableEntry</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(ppn: PhysPageNum, flags: PTEFlags) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        PageTableEntry &#123;</span><br><span class="line">            bits: ppn.<span class="number">0</span> &lt;&lt; <span class="number">10</span> | flags.bits <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Get the physical page number from the page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">ppn</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PhysPageNum &#123;</span><br><span class="line">        (<span class="keyword">self</span>.bits &gt;&gt; <span class="number">10</span> &amp; ((<span class="number">1usize</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>)).<span class="title function_ invoke__">into</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Get the flags from the page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">flags</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PTEFlags &#123;</span><br><span class="line">        PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.bits <span class="keyword">as</span> <span class="type">u8</span>).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="物理页帧与FrameAllocator"><a href="#物理页帧与FrameAllocator" class="headerlink" title="物理页帧与FrameAllocator"></a>物理页帧与FrameAllocator</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/config.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> MEMORY_END: <span class="type">usize</span> = <span class="number">0x80800000</span>;</span><br></pre></td></tr></table></figure>

<p>我们硬编码整块物理内存的终止物理地址为 <code>0x80800000</code> 。 而物理内存的起始物理地址为 <code>0x80000000</code> ， 意味着我们将可用内存大小设置为 8MiB ，当然也可以设置的更大一点。</p>
<blockquote>
<p>这里应当与ekernel的实现有关系，直接运算得到的结果并不是8MiB. 待补充…</p>
</blockquote>
<p>实现物理页帧管理器，以物理页号为单位进行物理页帧的分配和回收。物理页号区间 [ <code>current</code> , <code>end</code> ) 此前均 <em>从未</em> 被分配出去过，而向量 <code>recycled</code> 以后入先出的方式保存了被回收的物理页号（内核堆）。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>, <span class="comment">//空闲内存空间起始物理页号</span></span><br><span class="line">    end: <span class="type">usize</span>,</span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, l: PhysPageNum, r: PhysPageNum) &#123;</span><br><span class="line">        <span class="keyword">self</span>.current = l.<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.end = r.<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// trace!(&quot;last &#123;&#125; Physical Frames.&quot;, self.end - self.current);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将Trait<code>FrameAllocator</code>作用给<code>StackFrameAllocator</code>. 分配 <code>alloc</code> 的时候，首先会检查栈 <code>recycled</code> 内有没有之前回收的物理页号，如果有的话直接弹出栈顶并返回；否则的话我们只能从之前从未分配过的物理页号区间 [ <code>current</code> , <code>end</code> ) 上进行分配；回收的时候检测回收页面合法性</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FrameAllocator</span> <span class="keyword">for</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            current: <span class="number">0</span>,</span><br><span class="line">            end: <span class="number">0</span>,</span><br><span class="line">            recycled: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">alloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PhysPageNum&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(ppn) = <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(ppn.<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">self</span>.current == <span class="keyword">self</span>.end &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>((<span class="keyword">self</span>.current - <span class="number">1</span>).<span class="title function_ invoke__">into</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dealloc</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ppn</span> = ppn.<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// validity check</span></span><br><span class="line">        <span class="keyword">if</span> ppn &gt;= <span class="keyword">self</span>.current || <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">any</span>(|&amp;v| v == ppn) &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Frame ppn=&#123;:#x&#125; has not been allocated!&quot;</span>, ppn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// recycle</span></span><br><span class="line">        <span class="keyword">self</span>.recycled.<span class="title function_ invoke__">push</span>(ppn);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// another version of validity check</span></span><br><span class="line">        <span class="comment">// if ppn &gt;= self.current || self.recycled</span></span><br><span class="line">        <span class="comment">//     .iter()</span></span><br><span class="line">        <span class="comment">//     .find(|&amp;v| &#123;*v == ppn&#125;)</span></span><br><span class="line">        <span class="comment">//     .is_some() &#123;</span></span><br><span class="line">        <span class="comment">//     panic!(&quot;Frame ppn=&#123;:#x&#125; has not been allocated!&quot;, ppn);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>StackFrameAllocator</code>进行全局实例化与初始化.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FrameAllocatorImpl</span> = StackFrameAllocator;</span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="comment">/// frame allocator instance through lazy_static!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> FRAME_ALLOCATOR: UPSafeCell&lt;FrameAllocatorImpl&gt; =</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(FrameAllocatorImpl::<span class="title function_ invoke__">new</span>()) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// initiate the frame allocator using `ekernel` and `MEMORY_END`</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_frame_allocator</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ekernel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    FRAME_ALLOCATOR.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">init</span>(</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(ekernel <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">ceil</span>(),</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(MEMORY_END).<span class="title function_ invoke__">floor</span>(),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>FrameTracker</code>的构建如下，<code>frame_alloc</code> 的返回值类型并不是 物理页号 <code>PhysPageNum</code> ，而是将其进一步包装为一个 <code>FrameTracker</code>. 将一个物理页帧的生命周期绑定到一个 <code>FrameTracker</code> 变量上，当一个 <code>FrameTracker</code> 被创建的时候，我们需要从 <code>FRAME_ALLOCATOR</code> 中分配一个物理页帧：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="comment">/// physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new FrameTracker</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(ppn: PhysPageNum) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// page cleaning</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">bytes_array</span> = ppn.<span class="title function_ invoke__">get_bytes_array</span>();</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> bytes_array &#123;</span><br><span class="line">            *i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ppn &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，物理页帧<code>FrameTracker</code>仅由<code>ppn:PhysPageNum</code>所组成，而不包含偏移量。因为，<strong>每个物理页帧对应一连续的物理地址范围</strong>。要从物理页帧和页内偏移计算出具体物理地址，有公式：</p>
<p>PhysAddr &#x3D; FrameNumber * PageSize + Offset</p>
<p>当一个 <code>FrameTracker</code> 生命周期结束被编译器回收的时候，它的 <code>drop</code> 方法会<strong>自动</strong>被编译器调用. </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">frame_dealloc</span>(<span class="keyword">self</span>.ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Drop Trait有诸多便捷的特性，详细可见<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/4sv39-implementation-2.html#id4">管理 SV39 多级页表 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</a></p>
</blockquote>
<h4 id="多层页表"><a href="#多层页表" class="headerlink" title="多层页表"></a>多层页表</h4><p>每个应用的地址空间都对映一个不同的多级页表，这也就意味这不同页表的起始地址（即页表根节点的地址）是不一样的。因此 <code>PageTable</code> 要保存它根节点的物理页号 <code>root_ppn</code> 作为<strong>页表唯一的区分标志</strong>。此外， 向量 <code>frames</code> 以 <code>FrameTracker</code> 的形式保存了页表所有的节点（包括根节点）所在的<strong>物理页帧</strong>。</p>
<p><code>frame</code>是一个<code>FrameTracker</code>类型的变量，其具有唯一的结构体元素<code>ppn</code>(PhysPageNum).</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    root_ppn: PhysPageNum,</span><br><span class="line">    frames: <span class="type">Vec</span>&lt;FrameTracker&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="comment">/// Create a new page table</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        PageTable &#123;</span><br><span class="line">            root_ppn: frame.ppn,</span><br><span class="line">            frames: <span class="built_in">vec!</span>[frame],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了接续接下来的内容，此处我们需要理解SV39的页表机制。每个节点都被保存在一个物理页帧中。在 SV39 中，页表是分层结构，每一层的页表被称为一个<strong>节点</strong>。这些节点的作用是存储虚拟地址到物理地址的映射关系，或者指向下一层的页表。一个节点包含多个页表项（Page Table Entries, PTEs），每个页表项要么存储物理页帧地址，要么存储指向下一层页表的物理地址。<strong>每个节点会占据一个物理页帧</strong>。</p>
<p>在 SV39 中：</p>
<ul>
<li>一个页表条目（PTE）是 8 字节。</li>
<li>一个物理页帧大小是 4 KB。</li>
</ul>
<p>因此，一个物理页帧可以容纳： 4KB &#x2F; 8B &#x3D; 512 即 <strong>512 个页表条目</strong>。</p>
<p>通过这种设计，每个页表节点恰好是一个物理页帧，这简化了硬件设计：</p>
<ul>
<li>硬件可以直接通过 PPN（物理页帧号）定位到对应的页表节点。</li>
<li>页表查找只需通过偏移（Offset）找到具体的 PTE，而无需动态分配额外内存</li>
</ul>
<p>其实可以理解为，页表中的每一个基本单位都是一个物理页帧，此称为节点。</p>
<p>由此我们可以开始构建映射：为了 MMU 能够通过地址转换正确找到应用地址空间中的数据实际被内核放在内存中 位置，操作系统需要动态维护一个<strong>虚拟页号</strong>到<strong>页表项</strong>的映射，支持插入&#x2F;删除键值对，其方法签名如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags);</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个节点都被保存在一个物理页帧中，在多级页表的架构中，一个节点对应的物理页号作为指针指向该节点。一旦我们知道了指向某一个节点的物理页号，我们就需要能够修改这个节点的内容。在操作某个多级页表或是管理物理页帧的时候，我们要能够自由的读写一个给定的物理页号对应的物理页帧上的数据。</p>
<p>此处我们采用由<code>vpn</code>到<code>ppn</code>的<strong>恒等映射</strong>，此处还有其他映射方式如页表自映射等，可见<a href="https://os.phil-opp.com/paging-implementation/#accessing-page-tables">BlogOS中的相关介绍</a>.</p>
<h4 id="虚实地址映射"><a href="#虚实地址映射" class="headerlink" title="虚实地址映射"></a>虚实地址映射</h4><p>应用和内核的地址空间是隔离的。而直接访问物理页帧的操作只会在内核中进行， 应用无法看到物理页帧管理器和多级页表等内核数据结构。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/address.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PhysPageNum</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_pte_array</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> [PageTableEntry] &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pa</span>: PhysAddr = <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">into</span>();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(pa.<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">mut</span> PageTableEntry, <span class="number">512</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_bytes_array</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> [<span class="type">u8</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pa</span>: PhysAddr = <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">into</span>();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(pa.<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, <span class="number">4096</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>&lt;T&gt;(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pa</span>: PhysAddr = <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">into</span>();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            (pa.<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">mut</span> T).<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的512是因为一个页占4KB，每个页表项占 8 字节，4096 &#x2F; 8 总共 512 项，表示一个页表节点中的页表项数量。而4096就表示一个页的大小4 KB，即一个物理页帧的字节总数。</p>
<p>我们构造<strong>可变引用</strong>来直接访问一个物理页号 <code>PhysPageNum</code> 对应的物理页帧，不同的引用类型对应于物理页帧上的一种不同的 内存布局。如 <code>get_pte_array</code> 返回的是一个页表项定长数组的可变引用，可以用来修改多级页表中的一个节点；而 <code>get_bytes_array</code> 返回的是一个字节数组的可变引用，可以以字节为粒度对物理页帧上的数据进行访问。</p>
<p>在实现方面，先把物理页号转为物理地址 <code>PhysAddr</code> ，再转成 usize 形式的物理地址。接着，将它转为裸指针来访问物理地址指向的物理内存。在分页机制开启之后，虽然裸指针被视为一个虚拟地址， 但虚拟地址会映射到一个相同的物理地址，也成立。</p>
<blockquote>
<p>注意，返回值类型上附加静态生命周期泛型 <code>&#39;static</code> 以绕过 Rust 编译器的借用检查。实质上可以将返回的类型看作裸指针，因为它也只是标识数据存放的位置以及类型。但与裸指针不同的是，无需通过 <code>unsafe</code> 的解引用，而可以作为正常的可变引用一样直接访问。</p>
</blockquote>
<p><code>map</code>和<code>unmap</code>都依赖于在多级页表中找到一个虚拟地址对应的页表项的过程，找到之后，只要修改页表项的内容即可完成键值对的插入和删除。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/address.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">VirtPageNum</span> &#123;</span><br><span class="line">    <span class="comment">/// Get the indexes of the page table entry</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">indexes</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> [<span class="type">usize</span>; <span class="number">3</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vpn</span> = <span class="keyword">self</span>.<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">idx</span> = [<span class="number">0usize</span>; <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..<span class="number">3</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">            idx[i] = vpn &amp; <span class="number">511</span>;</span><br><span class="line">            vpn &gt;&gt;= <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">find_pte_create</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">        <span class="comment">/// Find PageTableEntry by VirtPageNum, create a frame for a 4KB page table if not exist</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[idxs[i]];</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">                result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);</span><br><span class="line">                <span class="keyword">self</span>.frames.<span class="title function_ invoke__">push</span>(frame);</span><br><span class="line">            &#125;</span><br><span class="line">            ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，  <code>indexes</code> 用于取出虚拟页号<code>vpn</code>的三级页索引，并按照从高到低的顺序返回。<code>find_pte_create</code>用于在<code>vpn</code>中三级页索引的指定下，逐级遍历各层<code>pte</code>。如果在遍历的过程中发现有节点尚未创建则会新建一个节点。</p>
<p>为了 <strong>MMU</strong> 能够通过地址转换正确找到应用地址空间中的数据实际被内核放在内存中 位置，操作系统需要动态维护一个<strong>虚拟页号</strong>到<strong>页表项</strong>的映射. 由此即可实现<code>map</code>与<code>unmap</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="comment">/// set the map between virtual page number and physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte_create</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(!pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is mapped before mapping&quot;</span>, vpn);</span><br><span class="line">        *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(ppn, flags | PTEFlags::V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// remove the map between virtual page number and physical page number</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte_create</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is invalid before unmapping&quot;</span>, vpn);</span><br><span class="line">        *pte = PageTableEntry::<span class="title function_ invoke__">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>vpn</code>对应的<code>pte</code>不可用，说明此时可以使用<code>map</code>进行映射.</p>
<blockquote>
<p>目前的实现方式并不打算对物理页帧耗尽的情形做任何处理而是直接 <code>panic</code> 退出。因此在前面的代码中能够看到 很多 <code>unwrap</code> ，这种使用方式并不为 Rust 所推荐，只是由于简单起见暂且这样做。</p>
</blockquote>
<p>我们还需要 <code>PageTable</code> 提供一种不经过 MMU 而是手动查页表的方法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="comment">/// Temporarily used to get arguments from user space.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_token</span>(satp: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            root_ppn: PhysPageNum::<span class="title function_ invoke__">from</span>(satp &amp; ((<span class="number">1usize</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>)),</span><br><span class="line">            frames: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">find_pte</span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;PageTableEntry&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">pte</span> = &amp;ppn.<span class="title function_ invoke__">get_pte_array</span>()[idxs[i]];</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">                result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">translate</span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;PageTableEntry&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte</span>(vpn)</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|pte| &#123;pte.<span class="title function_ invoke__">clone</span>()&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>translate</code> 通过调用 <code>find_pte</code> 来实现，如果能够找到页表项，那么它会将页表项拷贝一份并返回，否则就返回一个 <code>None</code>. 实现的是虚拟页号向PTE的转换.</p>
<h4 id="逻辑段与地址空间"><a href="#逻辑段与地址空间" class="headerlink" title="逻辑段与地址空间"></a>逻辑段与地址空间</h4><p>通过<strong>逻辑段</strong><code>MapArea</code>实现地址空间抽象，指地址区间中的一段实际可用（即 MMU 通过查多级页表 可以正确完成地址转换）的地址连续的<strong>虚拟地址区间</strong>，该区间内包含的所有虚拟页面都以一种相同的方式映射到物理页帧，具有可读&#x2F;可写&#x2F;可执行等属性。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="comment">/// map area structure, controls a contiguous piece of virtual memory</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MapArea</span> &#123;</span><br><span class="line">    vpn_range: VPNRange,</span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<strong>恒等映射</strong><code>Identical</code>，虚拟地址与物理地址完全一致，物理页号就等于虚拟页号，无需额外分配新的物理页帧；对Frame映射，可以指定<code>MapType::Framed</code>实现<strong>动态分配</strong>，即虚拟地址不直接对应任何已有的物理地址，而是通过页表映射到操作系统分配的空闲物理页帧，页表项中的物理页号即被分配的物理页帧的物理页号。此时，键值对容器 <code>BTreeMap</code> 中存放的物理页帧被用来存放实际内存数据。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MapArea</span>&#123;	</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ppn</span>: PhysPageNum;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.map_type &#123;</span><br><span class="line">            MapType::Identical =&gt; &#123;</span><br><span class="line">                ppn = <span class="title function_ invoke__">PhysPageNum</span>(vpn.<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            MapType::Framed =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                ppn = frame.ppn;</span><br><span class="line">                <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">insert</span>(vpn, frame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte_flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.map_perm.bits).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        page_table.<span class="title function_ invoke__">map</span>(vpn, ppn, pte_flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">vpn</span> <span class="keyword">in</span> <span class="keyword">self</span>.vpn_range &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">map_one</span>(page_table, vpn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// data: start-aligned but maybe with shorter length</span></span><br><span class="line">    <span class="comment">/// assume that all frames were cleared before</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">copy_data</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, data: &amp;[<span class="type">u8</span>]) &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="keyword">self</span>.map_type, MapType::Framed);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">start</span>: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">current_vpn</span> = <span class="keyword">self</span>.vpn_range.<span class="title function_ invoke__">get_start</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = data.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">src</span> = &amp;data[start..len.<span class="title function_ invoke__">min</span>(start + PAGE_SIZE)];</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">dst</span> = &amp;<span class="keyword">mut</span> page_table</span><br><span class="line">                .<span class="title function_ invoke__">translate</span>(current_vpn)</span><br><span class="line">                .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">                .<span class="title function_ invoke__">ppn</span>()</span><br><span class="line">                .<span class="title function_ invoke__">get_bytes_array</span>()[..src.<span class="title function_ invoke__">len</span>()];</span><br><span class="line">            dst.<span class="title function_ invoke__">copy_from_slice</span>(src);</span><br><span class="line">            start += PAGE_SIZE;</span><br><span class="line">            <span class="keyword">if</span> start &gt;= len &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current_vpn.<span class="title function_ invoke__">step</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map</code>可以对逻辑段所属地址空间的多级页表中加入每个虚拟页面的键值对映射，通过遍历逻辑段内所有虚拟页面而实现。<code>copy_data</code> 方法将切片 <code>data</code> 中的数据拷贝到当前逻辑段实际被内核放置在的各物理页帧上，从而在地址空间中通过该逻辑段就能访问这些数据。</p>
<p><strong>地址空间</strong><code>MemorySet</code>是一系列有关联的逻辑段，用来表明正在运行的应用所在执行环境中的可访问内存空间，在这个内存空间中，包含了一系列的<strong>不一定连续</strong>的逻辑段。这样我们就有任务（进程）的地址空间，内核的地址空间等说法了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="comment">/// address space</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MemorySet</span> &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="type">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意， <code>PageTable</code> 下 挂着所有多级页表的节点所在的物理页帧，而每个 <code>MapArea</code> 下则挂着对应逻辑段中的数据所在的物理页帧，这两部分合在一起构成了一个地址空间所需的所有物理页帧。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MemorySet</span>&#123;	</span><br><span class="line">	<span class="comment">/// Assume that no conflicts.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert_framed_area</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        start_va: VirtAddr,</span><br><span class="line">        end_va: VirtAddr,</span><br><span class="line">        permission: MapPermission,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            MapArea::<span class="title function_ invoke__">new</span>(start_va, end_va, MapType::Framed, permission),</span><br><span class="line">            <span class="literal">None</span>,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> map_area: MapArea, data: <span class="type">Option</span>&lt;&amp;[<span class="type">u8</span>]&gt;) &#123;</span><br><span class="line">        map_area.<span class="title function_ invoke__">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.page_table);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(data) = data &#123;</span><br><span class="line">            map_area.<span class="title function_ invoke__">copy_data</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.page_table, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.areas.<span class="title function_ invoke__">push</span>(map_area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>push</code> 方法可以在当前地址空间插入一个新的逻辑段 <code>map_area</code> ，如果它是以 <code>Framed</code> 方式映射到 物理内存，还可以可选地在那些被映射到的物理页帧上写入一些初始化数据 <code>data</code>.  而<code>insert_framed_area</code> 方法调用 <code>push</code> ，在当前地址空间插入一个映射到物理内存的逻辑段，该方法需保证同一地址空间内的任意两个逻辑段不能存在交集，从内核和应用的地址空间布局可以看出。</p>
<h4 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h4><p>在分页模式开启之后，内核与应用代码的访存地址都需要通过 MMU 转换变成物理地址，再交给 CPU 的访存单元去访问物理内存。地址空间抽象的重要意义在于 <strong>隔离</strong> (Isolation) ，执行每个应用的代码时，内核都需要控制 MMU 使用此应用地址空间对应的多级页表进行地址转换。每个应用地址空间只能访问自己的数据而无法触及其他应用或是内核的数据。</p>
<p>内核代码的访存地址也会被视为一个虚拟地址，并需要经过 MMU 的地址转换。因此我们需要为内核构造一个地址空间，它除了仍然允许内核的各数据段能够被正常访问之外，还需要包含所有应用的内核栈以及一个<strong>跳板</strong> (Trampoline) .</p>
<p>在<a href="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html#high-and-low-256gib">最高的256GB与最低的256GB</a>中，曾提过只有最低的256GB<code>0x0000_0000_0000~0x0000_7FFF_FFFF</code>，最高的256GB<code>0xFFFF_8000_0000~0xFFFF_FFFF_FFFF</code>，是可以通过MMU检查的，而中间部分<code>0x0000_8000_0000~0xFFFF_7FFF_FFFF</code>都为非法地址。</p>
<p>下图是软件看到的 64 位地址空间在 SV39 分页模式下实际可能通过 MMU 检查的最高256GB， 跳板放在最高的一个虚拟页面中。接下来则是从高到低放置每个应用的内核栈，内核栈的大小由 <code>config</code> 子模块的 <code>KERNEL_STACK_SIZE</code> 给出。</p>
<img src="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/kernel-as-high.png" alt="最高256GB" style="zoom:67%;" />

<p>相邻两个内核栈之间会预留一个 <strong>保护页面</strong> (Guard Page) ，它是内核地址空间中的空洞，多级页表中并不存在与它相关的映射。 它的意义在于当内核栈空间不足（如调用层数过多或死递归）的时候，代码会尝试访问空洞区域内的虚拟地址，然而它无法在多级页表中找到映射，便会触发异常，此时控制权会交给 trap handler 对这种情况进行 处理。</p>
<p>内核地址空间的低 256GiB 的布局：</p>
<img src="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/kernel-as-low.png" alt="低256GB" style="zoom:67%;" />

<p>四个逻辑段 <code>.text/.rodata/.data/.bss</code> 被恒等映射到物理内存。此外，内核地址空间中需要存在一个恒等映射到内核数据段之外的可用物理页帧的逻辑段，这样才能在启用页表机制之后，内核仍能以纯软件的方式读写这些物理页帧。<code>new_kernel</code>函数作用于创建一个包含低256GiB布局的地址空间，通过<code>push()</code>各逻辑段组成。</p>
<h4 id="应用地址空间"><a href="#应用地址空间" class="headerlink" title="应用地址空间"></a>应用地址空间</h4><p>我们希望效仿内核地址空间的设计，同样借助页表机制使应用地址空间的各个逻辑段也可有不同的访问方式限制，以提早检测应用的错误并及时将其终止。在第三章中，每个应用链接脚本中的起始地址被要求是不同的，这样代码和数据存放的位置才不会产生冲突。现在，所有应用程序都将使用同样的起始地址，所有应用可以使用同一个链接脚本<code>linker.ld</code>.</p>
<img src="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/app-as-full.png" alt="应用地址空间" style="zoom:67%;" />

<p>左侧给出了应用地址空间最低 256GiB 的布局：从 0x0 开始向高地址放置应用内存布局中的各个逻辑段，最后放置带有一个保护页面的用户栈。这些逻辑段都是以 <code>Framed</code> 方式映射到物理内存的。<code>U</code>表示可以在用户特权级时执行访问。右侧则给出了最高的 256GiB ， 它和内核地址空间一样将跳板放置在最高页，还将 Trap 上下文放置在次高页中。</p>
<p>在 <code>os/src/build.rs</code> 中，我们不再将丢弃了所有符号的应用二进制镜像链接进内核，而是直接使用 ELF 格式的可执行文件， 因为在前者中内存布局中各个逻辑段的位置和访问限制等信息都被裁剪掉了。而 <code>loader</code> 子模块也变得极其精简。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/loader.rs</span></span><br><span class="line"><span class="comment">/// Get the total number of applications.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_num_app</span>() <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">_num_app</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; (_num_app <span class="keyword">as</span> <span class="type">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>).<span class="title function_ invoke__">read_volatile</span>() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// get applications data</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_app_data</span>(app_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> [<span class="type">u8</span>] &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">_num_app</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_app_ptr</span> = _num_app <span class="keyword">as</span> <span class="type">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_app</span> = <span class="title function_ invoke__">get_num_app</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_start</span> = <span class="keyword">unsafe</span> &#123; core::slice::<span class="title function_ invoke__">from_raw_parts</span>(num_app_ptr.<span class="title function_ invoke__">add</span>(<span class="number">1</span>), num_app + <span class="number">1</span>) &#125;;</span><br><span class="line">    <span class="built_in">assert!</span>(app_id &lt; num_app);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">            app_start[app_id] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">            app_start[app_id + <span class="number">1</span>] - app_start[app_id],</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处原文档对<code>from_elf()</code>进行了讲解，待补充…</p>
</blockquote>
<h4 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h4><p>SBI初始化完成后，CPU将跳转到内核入口点并在S特权级上运行，此时还未开启分页模式。在内核初始化期间，将过渡到分页模式。</p>
<p>我们先创建内核地址空间的全局实例，这里使用经典的 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 组合是因为我们既需要 <code>Arc&lt;T&gt;</code> 提供的共享引用，也需要 <code>Mutex&lt;T&gt;</code> 提供的互斥访问：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/memory_set.rs</span></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="comment">/// The kernel&#x27;s initial memory mapping(kernel address space)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> KERNEL_SPACE: Arc&lt;UPSafeCell&lt;MemorySet&gt;&gt; =</span><br><span class="line">        Arc::<span class="title function_ invoke__">new</span>(<span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(MemorySet::<span class="title function_ invoke__">new_kernel</span>()) &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>rust_main</code> 函数中，我们首先调用 <code>mm::init</code> 进行内存管理子系统的初始化：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/mod.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> memory_set::KERNEL_SPACE;</span><br><span class="line"><span class="comment">/// initiate heap allocator, frame allocator and kernel space</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>() &#123;</span><br><span class="line">    heap_allocator::<span class="title function_ invoke__">init_heap</span>();</span><br><span class="line">    frame_allocator::<span class="title function_ invoke__">init_frame_allocator</span>();</span><br><span class="line">    KERNEL_SPACE.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">activate</span>();</span><br><span class="line">    <span class="comment">// v3: KERNEL_SPACE.lock().activate();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们最先进行全局动态内存分配器的初始化，接着初始化物理页帧管理器（内含堆数据结构 <code>Vec&lt;T&gt;</code> ）使能可用物理页帧的分配和回收能力。最后创建内核地址空间并让 CPU 开启分页模式， MMU 在地址转换时将使用内核的多级页表。</p>
<p>我们分析内核地址空间创建这一句。首先引用 <code>KERNEL_SPACE</code> ，由于是第一次被使用，此时它会被初始化，调用 <code>MemorySet::new_kernel</code> 创建一个内核地址空间并使用 <code>Arc&lt;UPSafeCell&lt;T&gt;&gt;</code> 包裹起来；</p>
<blockquote>
<p>在 rcore-v3 文档中，内核地址空间被<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>包裹，初始化时调用<code>KERNEL_SPACE.lock().activate()</code>.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span>&#123;</span><br><span class="line">    <span class="comment">/// get the token from the page table</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">token</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="number">8usize</span> &lt;&lt; <span class="number">60</span> | <span class="keyword">self</span>.root_ppn.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据<a href="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html#satp-layout">实现 SV39 多级页表机制（上） — rCore-Tutorial-Book-v3 0.1 文档</a>，当<code>satp</code>的<code>MODE</code>字段设置为8时，SV39分页机制被启用。<code>PageTable::token</code>用于构造<code>satp</code>开启分页模式，并填充多级页表根节点所在的物理页号。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">MemorySet</span>&#123;</span><br><span class="line">	<span class="comment">/// Change page table by writing satp CSR Register.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">activate</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">satp</span> = <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">token</span>();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            satp::<span class="title function_ invoke__">write</span>(satp);</span><br><span class="line">            asm!(<span class="string">&quot;sfence.vma&quot;</span>);</span><br><span class="line">            <span class="comment">// v3: llvm_asm!(&quot;sfence.vma&quot; :::: &quot;volatile&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>activate</code>将得到的<code>token</code>作为<code>satp</code>写入。<code>sfence.vma</code>包含清空快表TLB的操作。</p>
<p>注意，切换satp的指令附近的映射必须连续性，切换 satp 的指令及其下一条指令这两条相邻的指令的虚拟地址是相邻的。此处，这条写入 satp 的指令及其下一条指令都在内核内存布局的代码段中，在切换之后是一个恒等映射， 而在切换之前是视为物理地址直接取指，也可以将其看成一个恒等映射。这完全符合我们的期待：即使切换了地址空间，指令仍应该能够被<strong>连续</strong>的执行。</p>
<p>此外，我们可用<code>mm::remap_test</code>函数检查<code>mm:init</code>之后内核地址空间的多级页表是否被正确设置，分别通过手动查内核多级页表的方式验证代码段和只读数据段不允许被写入，同时不允许从数据段上取指。</p>
<h4 id="跳板Trampoline"><a href="#跳板Trampoline" class="headerlink" title="跳板Trampoline"></a>跳板Trampoline</h4><p>在启用分页机制后，对于Trap处理时我们需要修改satp以完成应用&#x2F;内核地址空间的切换。地址空间的切换不能影响指令的连续执行，即要求应用和内核地址空间在切换地址空间指令附近是平滑的。</p>
<blockquote>
<p>Q：为什么将 Trap 上下文放到应用地址空间的次高页面而不是内核地址空间中的内核栈中呢？</p>
<p>A：为了在内核栈中保存上下文，需要以下步骤：</p>
<ul>
<li>切换到内核地址空间<ul>
<li>将内核地址空间的 token 写入 <code>satp</code> 寄存器（切换页表）。</li>
</ul>
</li>
<li>定位内核栈顶<ul>
<li>需要一个通用寄存器保存内核栈的栈顶指针。</li>
</ul>
</li>
</ul>
<p>但硬件只提供了一个 <code>sscratch</code> 寄存器作为临时寄存器，无法同时保存两个信息。这会导致寄存器冲突。因此，我们在应用地址空间的次高页面预留一个虚拟页面，专门用于保存 Trap 上下文。当 Trap 发生时：</p>
<ul>
<li>硬件直接使用当前地址空间（即应用的页表）定位上下文保存位置。</li>
<li>无需切换到内核地址空间，也无需额外的寄存器来保存内核栈信息。</li>
</ul>
</blockquote>
<p>此处，上下文新添加的内容在初始化之后，只会被读取而不会被写入 ，无需每次都保存或恢复。在应用初始化时由内核写入应用地址空间中的 TrapContext 的相应位置，此后就不再被修改。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/trap/context.rs</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="comment">/// trap context structure containing sstatus, sepc and registers</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TrapContext</span> &#123;</span><br><span class="line">    <span class="comment">/// General-Purpose Register x0-31</span></span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="type">usize</span>; <span class="number">32</span>],</span><br><span class="line">    <span class="comment">/// Supervisor Status Register</span></span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="comment">/// Supervisor Exception Program Counter</span></span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// *Token of kernel address space</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_satp: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// *Kernel stack pointer of the current application</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_sp: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// *Virtual address of trap handler entry point in kernel</span></span><br><span class="line">    <span class="keyword">pub</span> trap_handler: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>trap.S</code>与<code>linker.ld</code>汇编代码部分待补充</p>
</blockquote>
<p>刚产生trap时，CPU已经进入了内核态（即Supervisor Mode），但此时执行代码和访问数据还是在应用程序所处的用户态虚拟地址空间中。为保持CPU指令的连续执行，应用的用户态虚拟地址空间 和 操作系统内核的内核态虚拟地址空间 对切换地址空间的指令所在页的映射方式均是相同的。无论是内核还是应用的地址空间，跳板的虚拟页均位于同样位置，且它们也将会映射到同一个 实际存放这段 汇编代码的物理页帧。</p>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
</search>
