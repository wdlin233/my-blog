<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Rust学习日志-Rustlings</title>
    <url>/2024/10/20/Rust%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-Rustlings/</url>
    <content><![CDATA[<h4 id="2024-9-29"><a href="#2024-9-29" class="headerlink" title="2024&#x2F;9&#x2F;29"></a>2024&#x2F;9&#x2F;29</h4><p>配置环境，WSL2下的Rust环境及WSL2与vscode的连接</p>
<h4 id="2024-10-1"><a href="#2024-10-1" class="headerlink" title="2024&#x2F;10&#x2F;1"></a>2024&#x2F;10&#x2F;1</h4><p>复习一下先前学的所有权与引用相关的知识，还有Rust中字符串的处理。稍微看了下方法 Method的使用。</p>
<p>可变引用与不可变引用的核心就在于：<strong>同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用</strong>。</p>
<p>完成Rustlings的struct和enums习题(31-36)。</p>
<p>enums3需要match表达式的相关知识，学习了一点模式匹配。</p>
<p>又做了strings(37-40).</p>
<span id="more"></span>

<h4 id="2024-10-2"><a href="#2024-10-2" class="headerlink" title="2024&#x2F;10&#x2F;2"></a>2024&#x2F;10&#x2F;2</h4><p>做练习的进度跟不上学习语法的进度，继续读Rust Course，有些地方还是不理解，尤其是Trait的部分。感觉看完能够看懂，但是不知道整体这么设计的目的。似乎Trait是Rust实现与C++继承类似的功能而做的复用性设计，而特征变量就是复用不同的Trait，再做了一层抽象。</p>
<p>读2.8泛型与特征、2.9集合类型、2.12包与模块。</p>
<p>写modules和hashmaps(41-46).</p>
<p>写hashmaps3(46)时有一个疑惑，<code>or_insert()</code>应返回一个<code>&amp; mut v</code>的引用类型，<strong>使用引用时应当先解引用</strong>，但我可以直接写<code>v1.goals_scored += team_1_score</code>. 不知道是为什么？</p>
<p>再做options(47-49).</p>
<p>errors1(50).</p>
<h4 id="2024-10-3"><a href="#2024-10-3" class="headerlink" title="2024&#x2F;10&#x2F;3"></a>2024&#x2F;10&#x2F;3</h4><p>继续Rustlings(errors2-6, 51-55, generics1-2, 56-57, traits 58-62). </p>
<p>做errors2和errors3的时候，总算明白了之前出现多次的<code>.unwrap()</code>的含义，就是取正确返回的<code>Result</code> 或 <code>Option</code> 类型的返回值。另外还遇到了<code>.unwrap_err().to_string()</code>这个操作，<code>unwrap_err()</code>的意思是，将<code>Ok()</code>或者<code>Err()</code>中的值取出并报错。参考<a href="https://blog.csdn.net/weixin_40482577/article/details/137244187">RUST 中什么情况下要使用 .unwrap ( )_rust unwrap-CSDN博客</a>.</p>
<p>errors5使用<code>Box&lt;dyn error::Error&gt;</code>，还是不是很理解Box是怎么使用。在这里是<code>Result&lt;_, E&gt;</code>的返回值，为什么最后使用的是<code>error:Error</code>?</p>
<p>errors6似懂非懂，可以理解到需要<code>CreationError</code>和<code>ParseIntError</code>两种错误类型的检测。所以似乎是先用一层<code>map_err()?</code>，之后再用一层<code>map_err()</code>. 检测两次。</p>
<p>traits5此处运用了多重约束，本质上是一个泛型为基础的语法糖，在<a href="https://course.rs/basic/trait/trait.html#%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9Ftrait-bound">Rust语言圣经</a>中有详细讨论。</p>
<h4 id="2024-10-4"><a href="#2024-10-4" class="headerlink" title="2024&#x2F;10&#x2F;4"></a>2024&#x2F;10&#x2F;4</h4><p>继续做tests.(63-68)</p>
<p>tests5有点令人疑惑，传入值是<code>&amp;mut t as *mut u32 as usize</code>，感觉令人无从下手。经过其自带注释的启发，先将传入的<code>mut address: usize</code>转为<code>*mut u32</code>的指针类型，再对指针所指向地址解引用修改即可。 </p>
<p>tests6考察的是用<code>into_raw()</code>创建野指针的处理方式，可见<a href="https://course.rs/advance/unsafe/superpowers.html?highlight=into_raw#%E5%9F%BA%E4%BA%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E8%A3%B8%E6%8C%87%E9%92%88">五种兵器 - Rust语言圣经(Rust Course)</a>，及<a href="https://vimsky.com/examples/usage/rust-std-boxed-struct.Box.into_raw-rt.html">Rust Box.into_raw用法及代码示例 - 纯净天空 (vimsky.com)</a>. 答案需要用到<code>from_raw()</code>来取指针，并对<code>*ptr.b</code>进行修改。</p>
<p><strong>果然不会做就应该及时看hint</strong>，此时的各种知识已经不是根据Rust圣经的排序了。</p>
<p>另外复习一下<code>to_owned()</code>这个函数，是获得其所有权的。参见<a href="https://zhuanlan.zhihu.com/p/687511216#:-:text=to_owned">Rust 的 to_owned 和 clone 的区别 - 知乎 (zhihu.com)</a>. 在tests6中，运用于<code>assert!(ret.b == Some(&quot;hello&quot;.to_owned()));</code></p>
<h4 id="2024-10-5"><a href="#2024-10-5" class="headerlink" title="2024&#x2F;10&#x2F;5"></a>2024&#x2F;10&#x2F;5</h4><p>tests7和tests8都是用<code>println!</code>输出命令，tests7是环境变量，tests8是条件编译。这里试错了很久，主要是不了解cargo这里的命令该如何使用。比较笨的是忘了使用<code>\</code>对<code>&quot;</code>进行转义。<a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-env">Build Scripts - The Cargo Book (rust-lang.org)</a>和<a href="https://doc.rust-lang.org/stable/cargo/reference/build-scripts.html#rustc-cfg">Build Scripts - The Cargo Book (rust-lang.org)</a></p>
<p>tests9是<code>#[no_mangle]</code>的应用，似乎是因为外部引用会导致函数名称的变化，这个属性就是让其保持原有的名称，不过我又重新定义了<code>my_demo_function_alias</code>这个函数，我怀疑我写错了，之后再看看。参考<a href="https://rustwiki.org/zh-CN/std/keyword.extern.html">extern - Rust (rustwiki.org)</a></p>
<p>lifetimes1, lifetimes2和lifetimes3都是圣经上的例子。</p>
<p>值得一提的是lifetimes3，是对结构体设置生命周期。或许可以说，我要让结构体和结构体内的成员处于同一作用域内，圣经<a href="https://course.rs/basic/compound-type/struct.html#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83">结构体 - Rust语言圣经(Rust Course)</a>中写：</p>
<blockquote>
<p>在之前的 <code>User</code> 结构体的定义中，有一处细节：我们使用了自身拥有所有权的 <code>String</code> 类型而不是基于引用的 <code>&amp;str</code> 字符串切片类型。这是一个有意而为之的选择：因为我们想要这个结构体拥有它所有的数据，而不是从其它地方借用数据</p>
</blockquote>
<p>Rutslings69-74.</p>
<h4 id="2024-10-7"><a href="#2024-10-7" class="headerlink" title="2024&#x2F;10&#x2F;7"></a>2024&#x2F;10&#x2F;7</h4><p>Rustlings(75-79, 80).</p>
<p>学习迭代器Iterator.</p>
<p>iterators2说是迭代器，不如说更多是字符串的操作. 看了hint后，说<code>first</code>是一个<code>char</code>. 看圣经说<code>next()</code>是一个消费者适配器，在这里似乎是将<code>c</code>的第一个字母去除了，但之后其他的字母都留存在<code>c</code>中，所以可以使用<code>as_str()</code>来转换.</p>
<blockquote>
<p>The variable <code>first</code> is a <code>char</code>. It needs to be capitalized and added to the remaining characters in <code>c</code> in order to return the correct <code>String</code>. The remaining characters in <code>c</code> can be viewed as a string slice using the<code>as_str</code> method.</p>
</blockquote>
<p>iterators4不知道该怎么用迭代器来实现，这里用<code>(1..num+1).product()</code>非常巧妙.</p>
<p>iterators5这里的类型有点令人困惑，我查询<code>.values()</code>函数得到</p>
<blockquote>
<p>pub fn <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#method.values">values</a>(&amp;self) -&gt; <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.Values.html">Values</a>&lt;’_, K, V&gt; <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#">ⓘ</a><br>An iterator visiting all values in arbitrary order. The iterator element type is <code>&amp;&#39;a V</code></p>
</blockquote>
<p>所以在使用<code>filter()</code>指定类型时，应写<code>map.values().filter(|&amp;x| *x == value).count()</code></p>
<p>对于<code>flat_map()</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">words</span> = [<span class="string">&quot;alpha&quot;</span>, <span class="string">&quot;beta&quot;</span>, <span class="string">&quot;gamma&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// chars() returns an iterator</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">merged</span>: <span class="type">String</span> = words.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">                          .<span class="title function_ invoke__">flat_map</span>(|s| s.<span class="title function_ invoke__">chars</span>())</span><br><span class="line">                          .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(merged, <span class="string">&quot;alphabetagamma&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>所以<code>collection.iter().flat_map(|x| x.values()).filter(|&amp;x| *x == value).count() </code>中的<code>x.values()</code>似乎就是返回一个迭代器对象，对迭代器中的每个元素再单独创建一个迭代器对象，该迭代器只有一个元素.</p>
<hr>
<p>再学习多线程thread. <code>join()</code>方法可以让当前线程阻塞等待多线程的完成. <code>thread::spawn</code>取得的对象是<code>JoinHandle&lt;u128&gt;</code>，故需要用’<code>join()</code>取得. 我们得到的是<code>Result</code>类型，需要用<code>expect()</code>取得<code>Ok</code>值，若不成功取得则返回错误信息.</p>
<h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><blockquote>
<p>To learn when a thread completes, it is necessary to capture the <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html"><code>JoinHandle</code></a> object that is returned by the call to <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>spawn</code></a>, which provides a <code>join</code> method that allows the caller to wait for the completion of the spawned thread:</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">thread_join_handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="comment">// some work here</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// some work here</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">res</span> = thread_join_handle.<span class="title function_ invoke__">join</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join"><code>join</code></a> method returns a <a href="https://doc.rust-lang.org/std/thread/type.Result.html"><code>thread::Result</code></a> containing <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a> of the final value produced by the spawned thread, or <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a> of the value given to a call to <a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a> if the thread panicked.</p>
</blockquote>
<h5 id="expect"><a href="#expect" class="headerlink" title="expect()"></a>expect()</h5><blockquote>
<p>Returns the contained <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a> value, consuming the <code>self</code> value.</p>
<p>Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a> case explicitly, or call <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or"><code>unwrap_or</code></a>, <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else"><code>unwrap_or_else</code></a>, or <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_default"><code>unwrap_or_default</code></a>.</p>
<p>Panics if the value is an <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a>, with a panic message including the passed message, and the content of the <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a>.</p>
</blockquote>
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">Result in std::result - Rust (rust-lang.org)</a></p>
<p>另外，对于经常出现的<code>unwrap()</code>函数，也做下记录：对于<code>Option</code>取<code>Some</code>的值，对于<code>Result</code>取<code>Ok</code>的值.</p>
<h4 id="2024-10-8"><a href="#2024-10-8" class="headerlink" title="2024&#x2F;10&#x2F;8"></a>2024&#x2F;10&#x2F;8</h4><p>多线程的锁结构需要智能指针的知识，再补.</p>
<p>Rustlings(81-82, 83-84).</p>
<p><strong>常规引用是一个指针类型</strong>，包含了目标数据存储的内存地址。对常规引用使用 <code>*</code> 操作符，就可以通过解引用的方式获取到内存地址对应的数据值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 <code>Deref</code> 后的智能指针结构体，就可以像普通引用一样，通过 <code>*</code> 进行解引用，例如 <code>Box&lt;T&gt;</code> 智能指针：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = *x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code> 类型，它其实是一个<strong>智能指针结构体</strong>. 对于函数和方法的传参，Rust 提供了一个极其有用的隐式转换：<code>Deref </code>转换。若一个类型实现了 <code>Deref</code> 特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行<strong>隐式的 <code>Deref</code> 转换</strong>，例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你以为 <code>Deref</code> 仅仅这点作用，那就大错特错了。<code>Deref</code> 可以支持连续的隐式转换，直到找到适合的形式为止：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>引用计数机制：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">2</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a), Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码我们使用 <code>Rc::new</code> 创建了一个新的 <code>Rc&lt;String&gt;</code> 智能指针并赋给变量 <code>a</code>，该指针指向底层的字符串数据。</p>
<p>智能指针 <code>Rc&lt;T&gt;</code> 在创建时，还会将引用计数加 1，此时获取引用计数的关联函数 <code>Rc::strong_count</code> 返回的值将是 <code>1</code>。</p>
<p>接着，我们又使用 <code>Rc::clone</code> 克隆了一份智能指针 <code>Rc&lt;String&gt;</code>，并将该智能指针的引用计数增加到 <code>2</code>。</p>
<p>由于 <code>a</code> 和 <code>b</code> 是同一个智能指针的两个副本，因此通过它们两个获取引用计数的结果都是 <code>2</code>。</p>
<p>不要被 <code>clone</code> 字样所迷惑，以为所有的 <code>clone</code> 都是深拷贝。这里的 <code>clone</code> <strong>仅仅复制了智能指针并增加了引用计数，并没有克隆底层数据</strong>，因此 <code>a</code> 和 <code>b</code> 是共享了底层的字符串 <code>s</code>，这种<strong>复制效率是非常高</strong>的。当然你也可以使用 <code>a.clone()</code> 的方式来克隆，但是从可读性角度，我们更加推荐 <code>Rc::clone</code> 的方式。</p>
<hr>
<p>因为<code>Mutex&lt;T&gt;</code>是一个智能指针，准确的说是<code>m.lock()</code>返回一个智能指针<code>MutexGuard&lt;T&gt;</code></p>
<ul>
<li>它实现了<code>Deref</code>特征，会被自动解引用后获得一个引用类型，该引用指向<code>Mutex</code>内部的数据</li>
<li>它还实现了<code>Drop</code>特征，在超出作用域后，自动释放锁，以便其它线程能继续获取锁</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用`Mutex`结构体的关联函数创建新的互斥锁实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取锁，然后deref为`m`的引用</span></span><br><span class="line">        <span class="comment">// lock返回的是Result</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">// 锁自动被drop</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;:?&#125;&quot;</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前章节，我们提到过<a href="https://course.rs/advance/smart-pointer/cell-refcell.html#%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7">内部可变性</a>，其中<code>Rc&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>的结合，可以实现单线程的内部可变性。</p>
<p>现在我们又有了新的武器，由于<code>Mutex&lt;T&gt;</code>可以支持修改内部数据，当结合<code>Arc&lt;T&gt;</code>一起使用时，可以实现多线程的内部可变性。</p>
<p>简单总结下：<code>Rc&lt;T&gt;/RefCell&lt;T&gt;</code>用于单线程内部可变性， <code>Arc&lt;T&gt;/Mutex&lt;T&gt;</code>用于多线程内部可变性。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>threads2是<code>Mutex</code>和<code>Arc</code>的综合运用，还结合了结构体，有点复杂. 关键在于<code>status_shared.lock().unwrap().jobs_completed += 1;</code>这个复合，最后输出也是类似，<code>println!(&quot;jobs completed &#123;&#125;&quot;, status.lock().unwrap().jobs_completed);</code>即可.</p>
<p>threads3和圣经中多发送者<a href="https://course.rs/advance/concurrency-with-threads/message-passing.html#%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%8F%91%E9%80%81%E8%80%85">线程同步：消息传递 - Rust语言圣经(Rust Course)</a>的例子很相似：由于子线程会拿走发送者的所有权，因此我们必须对发送者进行克隆，然后让每个线程拿走它的一份拷贝: <code>let tx1 = tx.clone();</code>.</p>
<p>Box1是圣经里的例子<a href="https://course.rs/advance/smart-pointer/box.html#%E5%B0%86%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B%E5%8F%98%E4%B8%BA-sized-%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B">Box堆对象分配 - Rust语言圣经(Rust Course)</a>，避免动态大小类型而在定义时使用<code>Box&lt;T&gt;</code>.</p>
<h4 id="2024-10-9"><a href="#2024-10-9" class="headerlink" title="2024&#x2F;10&#x2F;9"></a>2024&#x2F;10&#x2F;9</h4><p>Rustlings(85-86, 87-90, 91-93).</p>
<p>cow1使用<code>Cow</code>这个智能指针，处理的是所有权与可修改的问题。当其数据不拥有所有权时，不修改内容就返回不可变引用，修改内容便返回可变引用.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Cow</span>&lt;<span class="symbol">&#x27;a</span>, B&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    B: <span class="symbol">&#x27;a</span> + <span class="built_in">ToOwned</span> + ?<span class="built_in">Sized</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">Borrowed</span>(&amp;<span class="symbol">&#x27;a</span> B),</span><br><span class="line">    <span class="title function_ invoke__">Owned</span>(&lt;B <span class="keyword">as</span> <span class="built_in">ToOwned</span>&gt;::Owned),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::borrow::Cow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">abs_all</span>(input: &amp;<span class="keyword">mut</span> Cow&lt;<span class="symbol">&#x27;_</span>, [<span class="type">i32</span>]&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..input.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v</span> = input[i];</span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Clones into a vector if not already owned.</span></span><br><span class="line">            input.<span class="title function_ invoke__">to_mut</span>()[i] = -v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No clone occurs because `input` doesn&#x27;t need to be mutated.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = Cow::<span class="title function_ invoke__">from</span>(&amp;slice[..]);</span><br><span class="line"><span class="title function_ invoke__">abs_all</span>(&amp;<span class="keyword">mut</span> input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clone occurs because `input` needs to be mutated.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = Cow::<span class="title function_ invoke__">from</span>(&amp;slice[..]);</span><br><span class="line"><span class="title function_ invoke__">abs_all</span>(&amp;<span class="keyword">mut</span> input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// No clone occurs because `input` is already owned.</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = Cow::<span class="title function_ invoke__">from</span>(<span class="built_in">vec!</span>[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="title function_ invoke__">abs_all</span>(&amp;<span class="keyword">mut</span> input);</span><br></pre></td></tr></table></figure>

<p>macros3在<code>mod</code>前加入<code>#[macro_use]</code>即可. 文件内结构如下:</p>
<ul>
<li>macros3<ul>
<li>mod my_macro</li>
<li>main</li>
</ul>
</li>
</ul>
<p>这里用的宏都不是很复杂，题目也只涉及基本的概念，感觉只是会用宏但是自己不会写.</p>
<p>clippy1想自己定义<code>pi</code>但失败，因为默认<code>#[deny(clippy::approx_constant)]</code>是开启的，可以使用<code>f32::consts::PI</code>.</p>
<p>clippy2和clippy3感觉都是需要我们避免的低级错误.</p>
<h4 id="2024-10-10"><a href="#2024-10-10" class="headerlink" title="2024&#x2F;10&#x2F;10"></a>2024&#x2F;10&#x2F;10</h4><p>读Weak与循环引用以及链表实现的部分内容.</p>
<p>conversations(94-98, 99-100)</p>
<p>对于<code>AsRef</code>:</p>
<blockquote>
<p>By creating a generic function that takes an <code>AsRef&lt;str&gt;</code> we express that we want to accept all references that can be converted to <a href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a> as an argument. Since both <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> and <a href="https://doc.rust-lang.org/std/primitive.str.html"><code>&amp;str</code></a> implement <code>AsRef&lt;str&gt;</code> we can accept both as input argument.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">is_hello</span>&lt;T: <span class="built_in">AsRef</span>&lt;<span class="type">str</span>&gt;&gt;(s: T) &#123;</span><br><span class="line">   <span class="built_in">assert_eq!</span>(<span class="string">&quot;hello&quot;</span>, s.<span class="title function_ invoke__">as_ref</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">is_hello</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="title function_ invoke__">is_hello</span>(s);</span><br></pre></td></tr></table></figure>

<p><code>AsMut</code>类似:</p>
<blockquote>
<p>Using <code>AsMut</code> as trait bound for a generic function, we can accept all mutable references that can be converted to type <code>&amp;mut T</code>.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rustlings: as_ref_mut.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">num_sq</span>&lt;T: <span class="built_in">AsMut</span>&lt;<span class="type">u32</span>&gt;&gt;(arg: &amp;<span class="keyword">mut</span> T) &#123;</span><br><span class="line">    *arg.<span class="title function_ invoke__">as_mut</span>() *= *arg.<span class="title function_ invoke__">as_mut</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>复习一下<code>collect()</code>的用法:</p>
<blockquote>
<p>Transforms an iterator into a collection.</p>
<p><code>collect()</code> can take anything iterable, and turn it into a relevant collection. This is one of the more powerful methods in the standard library, used in a variety of contexts.</p>
<p><code>collect()</code> can also create instances of types that are not typical collections. For example, a <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> can be built from <a href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a>s, and an iterator of <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> items can be collected into <code>Result&lt;Collection&lt;T&gt;, E&gt;</code>. See the examples below for more.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">doubled</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = a.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">                         .<span class="title function_ invoke__">map</span>(|&amp;x| x * <span class="number">2</span>)</span><br><span class="line">                         .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>], doubled);</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">results</span> = [<span class="title function_ invoke__">Ok</span>(<span class="number">1</span>), <span class="title function_ invoke__">Err</span>(<span class="string">&quot;nope&quot;</span>), <span class="title function_ invoke__">Ok</span>(<span class="number">3</span>), <span class="title function_ invoke__">Err</span>(<span class="string">&quot;bad&quot;</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;_&gt;, &amp;<span class="type">str</span>&gt; = results.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// gives us the first error</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Err</span>(<span class="string">&quot;nope&quot;</span>), result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">results</span> = [<span class="title function_ invoke__">Ok</span>(<span class="number">1</span>), <span class="title function_ invoke__">Ok</span>(<span class="number">3</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;_&gt;, &amp;<span class="type">str</span>&gt; = results.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// gives us the list of answers</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Ok</span>(<span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">3</span>]), result);</span><br></pre></td></tr></table></figure>

<h4 id="2024-10-11"><a href="#2024-10-11" class="headerlink" title="2024&#x2F;10&#x2F;11"></a>2024&#x2F;10&#x2F;11</h4><p>quiz2: <a href="https://rustcc.cn/article?id=5111a32a-8134-4e4f-b9c1-17a1c354748c">话说to_string(), into(), to_owned(), from()区别是什么</a>讲解了字符串相关的几个函数.</p>
<blockquote>
<p><code>to_owned()</code>creates owned data from borrowed data, usually by cloning.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="type">str</span> = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ss</span>: <span class="type">String</span> = s.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: &amp;[<span class="type">i32</span>] = &amp;[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">vv</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = v.<span class="title function_ invoke__">to_owned</span>();</span><br></pre></td></tr></table></figure>

<p>其余的，<code>into()</code>是基于<code>Into</code>特征，实现类型转换；<code>from()</code>基于<code>From</code>特征，将类型<code>T</code>转换为指导类型，与<code>into()</code>对称；<code>to_string</code>是<code>ToString</code>特征的一部分，当一个类型实现<code>Display</code>特征时就会自动实现<code>ToString</code>.</p>
<h5 id="String-and-str"><a href="#String-and-str" class="headerlink" title="String and &amp;str"></a>String and &amp;str</h5><p>对于如下代码段，</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Command::<span class="title function_ invoke__">Append</span>(x) =&gt; string + &amp;<span class="string">&quot;bar&quot;</span>.<span class="title function_ invoke__">repeat</span>(*x)</span><br></pre></td></tr></table></figure>

<p>编译器会报错 </p>
<blockquote>
<p><code>+</code> cannot be used to concatenate two <code>&amp;str</code> strings.</p>
</blockquote>
<p>这里的关系有点复杂，我问了GPT-4o. 回答说:</p>
<p><code>&quot;bar&quot;.repeat(*x)</code> 会创建一个新的 <code>String</code>，因此 <code>&amp;&quot;bar&quot;.repeat(*x)</code> 的类型是 <code>&amp;String</code>, 而<code>string</code>变量得到的是<code>&amp;String</code>类型.</p>
<p><strong><code>+</code> 操作符需要左操作数是一个拥有所有权的 <code>String</code>，右操作数是一个 <code>&amp;str</code></strong>. 因此，当你使用 <code>string + &amp;&quot;bar&quot;.repeat(*x)</code> 时，存在类型不匹配的问题：</p>
<ul>
<li><code>string</code> 实际上是 <code>&amp;String</code>（需要转换为 <code>String</code>）</li>
<li><code>&amp;&quot;bar&quot;.repeat(*x)</code> 是 <code>&amp;String</code>（需要转换为 <code>&amp;str</code>）</li>
</ul>
<p>要解决这个问题，确保左操作数是一个 <code>String</code> 类型：</p>
<ul>
<li>使用 <code>string.to_owned()</code> 或 <code>string.clone()</code> 将 <code>&amp;String</code> 转为 <code>String</code>，以符合 <code>+</code> 操作符的要求：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Command::<span class="title function_ invoke__">Append</span>(x) =&gt; string.<span class="title function_ invoke__">to_owned</span>() + &amp;<span class="string">&quot;bar&quot;</span>.<span class="title function_ invoke__">repeat</span>(*x)</span><br></pre></td></tr></table></figure>

<p>这样操作后，<code>string.to_owned()</code> 会变成 <code>String</code> 类型，而 <code>&amp;&quot;bar&quot;.repeat(*x)</code> 会被<strong>自动解引用</strong>为 <code>&amp;str</code>，适合 <code>+</code> 操作符的要求。</p>
<p>网上的一些解答也显示，在此处<code>to_owned()</code>, <code>to_string()</code>, <code>into()</code>都可以.</p>
<hr>
<h5 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h5><p>参见 <a href="https://course.rs/basic/formatted-output.html">格式化输出 - Rust语言圣经(Rust Course)</a>.</p>
<p>与 <code>&#123;&#125;</code> 类似，<code>&#123;:?&#125;</code> 也是占位符：</p>
<ul>
<li><code>&#123;&#125;</code> 适用于实现了 <code>std::fmt::Display</code> 特征的类型，用来以更优雅、更友好的方式格式化文本，例如展示给用户</li>
<li><code>&#123;:?&#125;</code> 适用于实现了 <code>std::fmt::Debug</code> 特征的类型，用于调试场景</li>
</ul>
<p>其实两者的选择很简单，当你在写代码需要调试时，使用 <code>&#123;:?&#125;</code>，剩下的场景，选择 <code>&#123;&#125;</code>。</p>
<h6 id="Debug特征"><a href="#Debug特征" class="headerlink" title="Debug特征"></a>Debug特征</h6><p>事实上，为了方便我们调试，大多数 Rust 类型都实现了 <code>Debug</code> 特征或者支持派生该特征：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person&#123;name: <span class="string">&quot;sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(), age: <span class="number">18</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;</span>, i, s, v, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于数值、字符串、数组，可以直接使用 <code>&#123;:?&#125;</code> 进行输出，但是对于结构体，需要<a href="https://course.rs/appendix/derive.html">派生Debug</a>特征后，才能进行输出，总之很简单.</p>
<h6 id="Display特征"><a href="#Display特征" class="headerlink" title="Display特征"></a>Display特征</h6><p>与大部分类型实现了 <code>Debug</code> 不同，实现了 <code>Display</code> 特征的 Rust 类型并没有那么多，往往需要我们自定义想要的格式化方式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">i</span> = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">    name: <span class="string">&quot;sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, i, s, v, p);</span><br></pre></td></tr></table></figure>

<p>运行后可以看到 <code>v</code> 和 <code>p</code> 都无法通过编译，因为没有实现 <code>Display</code> 特征，但是你又不能像派生 <code>Debug</code> 一般派生 <code>Display</code>，只能另寻他法：</p>
<ul>
<li>使用 <code>&#123;:?&#125;</code> 或 <code>&#123;:#?&#125;</code></li>
<li>为自定义类型实现 <code>Display</code> 特征</li>
<li>使用 <code>newtype</code> 为外部类型实现 <code>Display</code> 特征</li>
</ul>
<p>一个比较经典的例子就是为结构体实现<code>Display</code>特征.</p>
<p>quiz3中的<code>impl&lt;T: std::fmt::Display&gt; ReportCard&lt;T&gt;</code>就是结合了结构体的<code>Display</code>特征与结构体内泛型数据的实现.</p>
<hr>
<p>algorithm1, 感觉还是有点难度，需要为泛型<code>T</code>实现<code>Ord</code>和<code>Clone</code>特征，然后在建立链表时和取变量时注意带上泛型的标注即可.</p>
<h4 id="2024-10-12"><a href="#2024-10-12" class="headerlink" title="2024&#x2F;10&#x2F;12"></a>2024&#x2F;10&#x2F;12</h4><p>algorithm2可以首先转换首尾节点<code>std::mem::swap(&amp;mut self.start, &amp;mut self.end);</code>.</p>
<p>然后我们可以考虑将包括头尾的所有节点的前驱指针与后继指针转换，这样头指针将会从后往前指向尾指针.</p>
<p>关键在于Rust中的指针操作:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(current_ptr) = current &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">node</span> = &amp;<span class="keyword">mut</span> *current_ptr.<span class="title function_ invoke__">as_ptr</span>();</span><br><span class="line">        <span class="comment">// 交换 next 和 prev 指针</span></span><br><span class="line">        std::mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> node.next, &amp;<span class="keyword">mut</span> node.prev);</span><br><span class="line">        <span class="comment">// 移动到下一个节点</span></span><br><span class="line">        current = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里解引用了裸指针，所以需要使用<code>unsafe</code>. 再者，<code>as_ptr()</code>是因为，直接解引用 <code>NonNull</code> 或裸指针违背了 Rust 的安全保证，因为这对后端优化器和静态分析器来说指针的变动的信息。所以我们需要使用 <code>as_ptr()</code> 返回一个原始指针，并告诉编译器“我知道我在使用一个底层指针”（这与 Rust 强类型系统的设计哲学一致：使你更清晰地表达你的意图）. </p>
<p>获取 <code>current_ptr</code> 所指向的节点的可变引用。<code>as_ptr()</code> 将 <code>NonNull</code> 转换为裸指针，而 <code>&amp;mut *</code> 会解引用裸指针并获取节点.</p>
<p>algorithms3思路不难，主要是其中各种API. 例如<code>len()</code>和<code>swap()</code>. 参见<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.swap">Vec in std::vec - Rust (rust-lang.org)</a></p>
<p>algorithm4主要还是递归，有几个需要注意:</p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p><strong>模式匹配时使用<code>ref</code>防止所有权转移</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">match</span> <span class="keyword">self</span>.root &#123;</span><br><span class="line">     <span class="title function_ invoke__">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> node) =&gt; node.<span class="title function_ invoke__">insert</span>(value),</span><br><span class="line">     <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">         <span class="keyword">self</span>.root = <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(TreeNode::<span class="title function_ invoke__">new</span>(value)));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="keyword">self</span>.root &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(node) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 这里使用了 node 的所有权</span></span><br><span class="line">        <span class="built_in">assert!</span>(node.left.<span class="title function_ invoke__">is_none</span>());</span><br><span class="line">        <span class="built_in">assert!</span>(node.right.<span class="title function_ invoke__">is_none</span>());</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Root should not be None after insertion&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>self.root</code> 为 <code>Some(node)</code>，那么 <code>node</code> 的所有权将被移动到这个模式内。</li>
<li>结果是，<code>self.root</code> 将变成无效的，因为它的内容（即 <code>node</code>）已经被移动，而 Rust 不允许重复使用已经被移动的变量。</li>
</ul>
<h4 id="2024-10-13"><a href="#2024-10-13" class="headerlink" title="2024&#x2F;10&#x2F;13"></a>2024&#x2F;10&#x2F;13</h4><h5 id="map-or"><a href="#map-or" class="headerlink" title="map_or()"></a>map_or()</h5><p>对于搜索结果，我们可以使用<code>map_or()</code>来处理.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_or</span>&lt;U, F&gt;(<span class="keyword">self</span>, default: U, f: F) <span class="punctuation">-&gt;</span> U</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>(T) <span class="punctuation">-&gt;</span> U,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Returns the provided default result (if none), or applies a function to the contained value (if any).</p>
<p>Arguments passed to <code>map_or</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or_else"><code>map_or_else</code></a>, which is lazily evaluated.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(x.<span class="title function_ invoke__">map_or</span>(<span class="number">42</span>, |v| v.<span class="title function_ invoke__">len</span>()), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; = <span class="literal">None</span>;</span><br><span class="line"><span class="built_in">assert_eq!</span>(x.<span class="title function_ invoke__">map_or</span>(<span class="number">42</span>, |v| v.<span class="title function_ invoke__">len</span>()), <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>为避免此处所有权的转移，我们可以使用<code>as_ref()</code>得到一个<strong>引用</strong>. 即<code>self.left.as_ref().map_or(false, |left| left.search(value))</code>.</p>
<p>另外，我们考虑使用<code>as_mut()</code> 方法，它能够从 <code>Option&lt;T&gt;</code> 生成一个 <code>Option&lt;&amp;mut T&gt;</code>，提供对其内部值的可变引用。这使得我们可以修改内部的值（例如，树节点的值）而不移动所有权。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(left) = <span class="keyword">self</span>.left.<span class="title function_ invoke__">as_mut</span>() &#123;</span><br><span class="line">    left.<span class="title function_ invoke__">insert</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>alogorithm5和algorithm6主要是要熟悉<code>VecDeque</code>和<code>HashSet</code>的API.</p>
<p>algorithm7自带的代码实现了迭代器的特性，可能我实现地有问题，我没有用到迭代器，就利用入栈、出栈与模式匹配就完成了这个练习.</p>
<h4 id="2024-10-14"><a href="#2024-10-14" class="headerlink" title="2024&#x2F;10&#x2F;14"></a>2024&#x2F;10&#x2F;14</h4><p>algorithm8是用队列模拟栈. 这里有一个比较好的思路是，始终将q1当作栈. 具体而言，就是让每次入栈的元素都成为q1的队首元素. 这通过依次出队原先的q1元素并使其入队q2而得.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, elem: T) &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="keyword">self</span>.q2.<span class="title function_ invoke__">enqueue</span>(elem);</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(e) = <span class="keyword">self</span>.q1.<span class="title function_ invoke__">dequeue</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.q2.<span class="title function_ invoke__">enqueue</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    std::mem::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.q1, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.q2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>algorithm9可以说是很不会了. 这里借鉴了很多，有空再完善这部分的笔记.</p>
<p>algorithm10这里我就实现了<code>add_edge()</code>. 感觉对Rust的std很不熟悉，其中使用<code>entry()</code>获取对应的Hash值，这个返回的结果可以被<code>or_insert_with()</code>处理，若不存在对应键则会自动插入；<code>or_insert_with()</code>会返回对应键值(<code>-&gt; V</code>)的可变引用.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.adjacency_table.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(node1))</span><br><span class="line">    .<span class="title function_ invoke__">or_insert_with</span>(<span class="type">Vec</span>::new)</span><br><span class="line">    .<span class="title function_ invoke__">push</span>((<span class="type">String</span>::<span class="title function_ invoke__">from</span>(node2), weight));</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/10/20/hello-world/</url>
    <content><![CDATA[<h2 id="第一部分-论神"><a href="#第一部分-论神" class="headerlink" title="第一部分 论神"></a>第一部分 论神</h2><h3 id="界说"><a href="#界说" class="headerlink" title="界说"></a>界说</h3><p>(一) 自因(causa sui)，我理解为这样的东西，它的本质(essentia)即包含存在(existentia)，或者它的本性只能设想为存在着。</p>
<p>(二) 凡是可以为同性质的另一事物所限制的东西，就叫做自类有限(insuo genere finita)。例如一个物体被称为有限，就是因为除了这个物体之外，我们常常可以设想另一个更大的物体。同样，一个思想可以为另一个思想所限制。但是物体不能限制思想，思想也不能限制物体。</p>
<p>(三) 实体(substantia)，我理解为在自身内并通过自身而被认识的东西。换言之，形成实体的概念，可以无须借助于他物的概念。</p>
<p>(四) 属性(attributus)，我理解为由知性(intellectus)看来是构成实体的 本质的东西。</p>
<p>(五) 样式(modus)，我理解为实体的分殊(affectiones)，亦即在他物内(inalio est)通过他物而被认知的东西(per alium concipitur)。</p>
<p>(六) 神(Deus)，我理解为绝对无限的存在，亦即具有无限“多”属性的实体，其中每一属性各表示永恒无限的本质。说明 我说神是绝对无限而不说它是自类无限(in suo genereinfinita)，因为仅仅是自类无限的东西，我们可以否认其无限多的属性；而绝对无限者的本性中就具备了一切足以表示本质的东西，却并不包含否定。</p>
<p>(七) 凡是仅仅由自身本性的必然性而存在、其行为仅仅由它自身决定的东西叫做自由(libera)。反之，凡一物的存在及其行为均按一定的方式为他物所决定，便叫做必然(necessaria，)或受制(coata)。</p>
<p>(八) 永恒(aeternitas)，我理解为存在的自身，就存在被理解为只能从永恒事物的界说中必然推出而言。</p>
<p><strong>说明</strong> 因为这样的存在也可以设想为永恒的真理，有如事物的本质，因此不可以用绵延或时间去解释它，虽说绵延可以设想为无始无终。</p>
]]></content>
  </entry>
  <entry>
    <title>OS学习日志</title>
    <url>/2024/10/21/OS%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h3 id="OS学习日志"><a href="#OS学习日志" class="headerlink" title="OS学习日志"></a>OS学习日志</h3><h4 id="2024-10-21"><a href="#2024-10-21" class="headerlink" title="2024&#x2F;10&#x2F;21"></a>2024&#x2F;10&#x2F;21</h4><p>chap2实现应用程序一部分，在OS启动时执行了<code>clear_bss()</code>函数，关于BSS的功能，参考<a href="https://blog.csdn.net/sgc_bf/article/details/101227860">静态存储区（Bss、数据段、代码段），堆，栈-CSDN博客</a>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="meta">#[link_section = <span class="string">&quot;.text.entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">main</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>lib.rs</code>中定义一个<code>main</code>函数，其具有弱链接特性。在编译过程中，弱符号遇到强符号时，会选择强符号而丢掉弱符号。参考<a href="https://zhuanlan.zhihu.com/p/55768978">嵌入式C语言自我修养 09：链接过程中的强符号和弱符号 - 知乎</a>.</p>
<span id="more"></span>

<p>故rCore文档中说：</p>
<blockquote>
<p>我们使用 Rust 宏将其标志为弱链接。这样在最后链接的时候， 虽然 <code>lib.rs</code> 和 <code>bin</code> 目录下的某个应用程序中都有 <code>main</code> 符号， 但由于 <code>lib.rs</code> 中的 <code>main</code> 符号是弱链接， 链接器会使用 <code>bin</code> 目录下的函数作为 <code>main</code> 。 如果在 <code>bin</code> 目录下找不到任何 <code>main</code> ，那么编译也能通过，但会在运行时报错。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![feature(linkage)]</span>    <span class="comment">// 启用弱链接特性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[linkage = <span class="string">&quot;weak&quot;</span>]</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Cannot find main!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在系统调用时，我们需要将对应的参数储存在寄存器中，这里我们需要了解RISC-V架构中寄存器的相关知识<a href="https://blog.csdn.net/weixin_42031299/article/details/132839814">RISV-V架构的寄存器介绍_riscv寄存器-CSDN博客</a>.</p>
<p>这里使用了Rust的内联汇编宏<code>asm!</code>，参考<a href="https://doc.rust-lang.org/nightly/reference/inline-assembly.html">Inline assembly - The Rust Reference</a>. 由于Rust 编译器无法判定汇编代码的安全性，所以我们需要将其包裹在 unsafe 块中.</p>
<p>简而言之，这条汇编代码的执行结果是以寄存器 <code>a0~a2</code> 来保存系统调用的参数，以及寄存器 <code>a7</code> 保存 syscall ID， 返回值通过寄存器 <code>a0</code> 传递给局部变量 <code>ret</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>: <span class="type">isize</span>;</span><br><span class="line">   <span class="keyword">unsafe</span> &#123;</span><br><span class="line">       core::arch::asm!(</span><br><span class="line">           <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">           <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">           <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">           <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">           <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br><span class="line">   ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 <code>inlateout(&quot;x10&quot;) args[0] =&gt; ret</code>：</p>
<ul>
<li><strong>传值</strong>：<code>args[0]</code> 是输入值，它会在调用 <code>ecall</code> 之前被加载到 <code>x10</code> 寄存器。</li>
<li><strong>返回结果</strong>：执行完 <code>ecall</code> 后，<code>x10</code> 的值变为结果值，并把这个结果存入变量 <code>ret</code>。</li>
</ul>
<p>于是我们基于<code>syscall</code>就可以实现一些基本的系统功能：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SYSCALL_WRITE: <span class="type">usize</span> = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buffer: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_WRITE, [fd, buffer.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, buffer.<span class="title function_ invoke__">len</span>()])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_EXIT, [xstate <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装，有</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"><span class="keyword">use</span> syscall::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(fd: <span class="type">usize</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123; <span class="title function_ invoke__">sys_write</span>(fd, buf) &#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit</span>(exit_code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123; <span class="title function_ invoke__">sys_exit</span>(exit_code) &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>chap2实现批处理操作系统一部分，对<code>link_app.S</code>的汇编代码，可以理解为<code>_num_app</code>这一全局符号指向了一个数组，一个表示应用程序数量，三个表示每个应用程序的开始地址，一个表示最后一个应用程序的结束地址。</p>
<p>汇编中的常用伪指令：</p>
<p><strong><code>.section</code></strong>:</p>
<ul>
<li>指定接下来的代码或数据属于哪一节（段）。常见的数据段有 <code>.text</code>（代码段）、<code>.data</code>（数据段）、<code>.bss</code>（未初始化数据段）等。</li>
</ul>
<p><strong><code>.align</code></strong>:</p>
<ul>
<li>用于指定数据的对齐。譬如，<code>.align 3</code> 会将接下来的数据对齐到 2^3&#x3D;8 字节的边界。</li>
</ul>
<p><strong><code>.global</code></strong> 或 <strong><code>.globl</code></strong>:</p>
<ul>
<li>用于声明符号为全局符号，使其在其他文件中可见。</li>
</ul>
<p><strong><code>.quad</code></strong>:</p>
<ul>
<li>用于分配并初始化一个 64-bit（8字节）数据。类似的指令有 <code>.byte</code>、<code>.word</code>、<code>.long</code> 等，用于分配其他大小的数据。</li>
</ul>
<p><strong><code>.incbin</code></strong>:</p>
<ul>
<li>包含一个外部二进制文件的内容，并将其嵌入到当前字节流中。这在需要将预编译的二进制文件直接打包到程序中的情况下非常有用。</li>
</ul>
<p>在初始化<code>AppManager</code>的代码中，<code>UPSafeCell</code>获取内部对象的可变引用，拥有内部可变性。<code>lazy_static!</code> 宏提供了全局变量的运行时初始化功能。对于有些全局变量，其初始化依赖于运行期间才能得到的数据。 此处声明了一个 <code>AppManager</code> 结构的名为 <code>APP_MANAGER</code> 的全局实例， 只有在它第一次被使用到的时候才会进行实际的初始化工作。</p>
<p>CPU的L1 Cache分为数据缓存(d-cache)和指令缓存(i-cache)，二者的大概介绍<a href="https://blog.csdn.net/chenhuanqiangnihao/article/details/128312905">CPU一级缓存L1 D-cache\L1 I-cache-CSDN博客</a>. 二者分别用来存放，数据和执行这些数据的指令，而且两者可以同时被CPU访问，减少了争用Cache所造成的冲突，提高了CPU效能。代码中我们使用汇编指令 <code>fence.i</code> 清理 i-cache.</p>
<h4 id="2024-10-22"><a href="#2024-10-22" class="headerlink" title="2024&#x2F;10&#x2F;22"></a>2024&#x2F;10&#x2F;22</h4><p>在RISC-V体系架构中，异常和中断的过程被统称为trap。广义的来说，中断也属于异常的一部分；不管发生异常或是中断，微处理器的硬件行为是一致的，<strong>微处理器暂停当前程序，转向异常或中断处理程序，处理完成后返回之前暂停的程序。</strong></p>
<p>关于触发异常<code>Trap</code>的情况:</p>
<ol>
<li>其一是用户态软件为获得内核态操作系统的服务功能而执行特殊指令<ul>
<li>指令本身属于高特权级的指令，如 <code>sret</code> 指令(表示从 S 模式返回到 U 模式)</li>
<li>指令访问了 <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/4trap-handling.html#term-s-mod-csr">S模式特权级下才能访问的寄存器</a> 或内存，如表示S模式系统状态的 <strong>控制状态寄存器</strong> <code>sstatus</code> 等</li>
</ul>
</li>
<li>其二是在执行某条指令期间产生了错误（如执行了用户态不允许执行的指令或者其他错误）并被 CPU 检测到</li>
</ol>
<p>网上有一些博客对此有更详细的介绍：<a href="https://blog.csdn.net/weixin_53479532/article/details/136611555">RISC-V 32架构实践专题九（从零开始写操作系统-trap机制）_mtval寄存器-CSDN博客</a>, 与<a href="https://www.cnblogs.com/chenhan-winddevil/p/18327630">rCore学习笔记 018-实现特权级的切换 - winddevil - 博客园</a>. 在RISC-V Reader中也有关于CSR的描述.</p>
<blockquote>
<p>mtvec（Machine Trap Vector），存放发生异常时处理器跳转的地址（图 10.7）<br>mepc（Machine Exception PC），指向发生异常的指令（图 10.8）。</p>
<p>RISC-V Reader: Page.105</p>
</blockquote>
<p>用户程序与操作系统的操作各属于不同的特权级，在系统（程序）运行时就涉及到特权级之间的切换。我们使用CSR来保存M&#x2F;S特权的各种状态；而涉及到保存与还原各种状态的需求，我们就有了用户栈与内存栈的区分。</p>
<h4 id="2024-10-23"><a href="#2024-10-23" class="headerlink" title="2024&#x2F;10&#x2F;23"></a>2024&#x2F;10&#x2F;23</h4><p>对于<code>csrrw rd, csr, rs1</code>，作用是将来自寄存器 <code>rs1</code> 的值写入控制和状态寄存器（CSR），并将CSR的旧值读入寄存器 <code>rd</code>. 因此这里起到的是交换<code> sscratch</code> 和<code> sp</code> 的效果。在这一行之前 <code>sp</code> 指向用户栈， <code>sscratch</code> 指向内核栈，现在 <code>sp</code> 指向内核栈， <code>sscratch</code> 指向用户栈。</p>
<p><code>addi sp, sp, -34*8</code>用于预先分配栈帧（内核栈），将<code>sp</code>的值与<code>-34*8</code>相加后存入<code>sp</code>.</p>
<p><code>sd rs2, offset(rs1)</code>，<code>sd</code> 指令的目的是将 <code>rs2</code> 寄存器中的64位数据存入由 <code>rs1</code> 中的地址加上 <code>offset</code> 计算得到的内存地址. 按照 <code>TrapContext</code> 结构体的内存布局，基于内核栈的位置（sp所指地址）来从低地址到高地址分别按顺序放置 <code>x0</code>~&#96;x31<code>这些通用寄存器，最后是 sstatus 和 sepc .  通用寄存器 xn 应该被保存在地址区间 </code>[sp+8n,sp+8(n+1))&#96; . </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.macro SAVE_GP n</span><br><span class="line">    sd x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">sd x1, 1*8(sp)</span><br><span class="line"># skip sp(x2), we will save it later</span><br><span class="line">sd x3, 3*8(sp)</span><br><span class="line"># skip tp(x4), application does not use it</span><br><span class="line"># save x5~x31</span><br><span class="line">.set n, 5</span><br><span class="line">.rept 27</span><br><span class="line">    SAVE_GP %n</span><br><span class="line">    .set n, n+1</span><br><span class="line">.endr</span><br></pre></td></tr></table></figure>

<p><code>__alltraps</code>和<code>__restore</code>作为对应操作，其思路完全相反.</p>
<p>Trap 处理的总体流程如下：首先通过 <code>__alltraps</code> <strong>将 Trap 上下文保存在内核栈上</strong>，然后跳转到使用 Rust 编写的 <code>trap_handler</code> 函数 完成 Trap 分发及处理。当 <code>trap_handler</code> 返回之后，使用 <code>__restore</code> 从保存在内核栈上的 Trap 上下文<strong>恢复寄存器</strong>。最后通过一条 <code>sret</code> 指令回到应用程序执行。</p>
<p>当批处理操作系统初始化完成，或者是某个应用程序运行结束或出错的时候，我们要调用 <code>run_next_app</code> 函数切换到下一个应用程序。类似地，当我们需要从S模式返回U模式时，我们也需要在内核栈上压入一个Trap上下文，之后通过<code>__restore</code>函数，让这些寄存器到达启动应用程序所需要的上下文状态。</p>
<hr>
<p>这里涉及到了特权切换的问题，整理一下，RISCV架构下有三种特权级别，分别是Machine、Supervisor和User，简称M模式、S模式和U模式。M模式权限最高，在这个级别下的程序可以访问一切硬件和执行所有特权指令；S模式一般用于运行操作系统，可以设置MMU使用虚拟地址；U模式一般是普通应用程序使用，权限最低。</p>
<p>在arm下的应用程序通过<code>swi</code>指令可以将处理器从低特权级别切换到高特权级别，一般像Linux下的系统调用都是通过这种方式来使用的。类似的，在RISCV中，通过<code>ecall</code>指令可以从低特权切换到高特权，在U模式下执行就切换到S模式，在S模式下调用就切换到M模式。另外在RISCV中，默认产生中断和异常时，处理器自动切换到M模式处理，可以通过中断托管设置将一些中断和异常直接交给S模式处理。</p>
<p>参见<a href="https://www.cnblogs.com/dream397/p/15687184.html">riscv 中断和异常处理 - tycoon3 - 博客园</a>.</p>
<h4 id="2024-10-24"><a href="#2024-10-24" class="headerlink" title="2024&#x2F;10&#x2F;24"></a>2024&#x2F;10&#x2F;24</h4><p>今天看到有人说rCore-v3的内容会更加详细，更好理解。翻了翻确实如此，竟然现在才知道。<em>我真傻，真的</em>。</p>
<p>先趁此复习一下ch2的内容：如果应用越过了硬件所设置特权级界限或主动申请获得操作系统的服务，就会触发 Trap 并进入到批处理系统中进行处理。可以看到，<strong>在内存中同一时间最多只需驻留一个应用</strong>。这是因为只有当一个应用出错或退出之后，批处理系统才会去将另一个应用加载到相同的一块内存区域。</p>
<p>对于多道程序的处理，发展出两种方式：</p>
<ul>
<li><p><strong>放弃处理器</strong>的操作算是一种对处理器资源的直接管理，所以应用程序可以发出这样的系统调用，让操作系统来具体完成。这样的操作系统就是支持 <strong>多道程序</strong> 协作式操作系统</p>
</li>
<li><p>把一个程序在一个时间片上占用处理器执行的过程称为一个 <strong>任务</strong> (Task)，让操作系统对不同程序的 <strong>任务</strong> 进行管理。通过平衡各个程序在整个时间段上的任务数，使一个包含多个时间片的时间段上，会有属于不同程序的多个任务在轮流占用处理器执行，这样的操作系统就是支持 <strong>分时多任务</strong> 的抢占式操作系统。</p>
</li>
</ul>
<p>在<code>load_apps()</code>中，第 <code>i</code>个应用被加载到以物理地址 <code>base_i</code> 开头的一段物理内存上，先清空<code>base_i</code>段的值，之后将<code>app_start[i]</code>的内容复制其上.</p>
<hr>
<p>我们将实现<strong>任务切换</strong>，任务切换支持的场景是：一个应用在运行途中便会主动交出 CPU 的使用权，此时它只能暂停执行，等到内核重新给它分配处理器资源之后才能恢复并继续执行。</p>
<p>我们就把应用程序的一个计算阶段的执行过程（也是一段执行流）称为一个 <strong>任务</strong> ，所有的任务都完成后，应用程序也就完成了。从一个程序的任务切换到另外一个程序的任务称为 <strong>任务切换</strong> 。为了确保切换后的任务能够正确继续执行，操作系统需要支持让任务的执行“暂停”和“继续”。</p>
<p>一旦一条执行流需要支持“暂停-继续”，就需要提供一种执行流切换的机制，而且需要保证执行流被切换出去之前和切换回来之后，它的状态，也就是在执行过程中同步变化的资源（如寄存器、栈等）需要<strong>保持不变</strong>，<strong>或者变化在它的预期之内</strong>。而不是所有的资源都需要被保存，事实上只有那些对于执行流接下来的进行仍然有用，且在它被切换出去的时候有被覆盖的风险的那些资源才有被保存的价值。这些物理资源被称为 <strong>任务上下文 (Task Context)</strong> 。</p>
<p>这里发现rCore-v3的手册写的很好，前面有些懵懂的概念都有详细的解释，应当往前翻看。</p>
<h4 id="2024-10-26"><a href="#2024-10-26" class="headerlink" title="2024&#x2F;10&#x2F;26"></a>2024&#x2F;10&#x2F;26</h4><p>于是开始重读rCore-v3.</p>
<h5 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h5><p>应用程序在执行过程中，如果出现外设中断或 CPU 异常，处理器执行的前一条指令和后一条指令会位于两个完全不同的位置，即不同的执行环境 。比如，前一条指令还在应用程序的代码段中，后一条指令就跑到操作系统的代码段中去了，这就是一种控制流的“突变”，即控制流脱离了其所在的执行环境，并产生 <a href="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/chapter0/3os-hw-abstract.html#term-ee-switch">执行环境的切换</a>。</p>
<p><strong>异常控制流</strong> (ECF, Exceptional Control Flow) 是处理器在执行过程中的突变，其主要作用是通过硬件和操作系统的协同工作来响应处理器状态中的特殊变化。比如当应用程序正在执行时，产生了时钟外设中断，导致操作系统打断当前应用程序的执行，转而进入 <strong>操作系统</strong> 所在的执行环境去处理时钟外设中断。处理完毕后，再回到应用程序的执行环境中被打断的地方继续执行。</p>
<h5 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h5><p>这里我们把控制流在执行完某指令时的物理资源内容，即确保下一时刻能继续 <em>正确</em> 执行控制流指令的物理资源内容称为控制流的 <strong>上下文</strong> (Context) ，也可称为控制流所在执行环境的状态。</p>
<p>这里需要理解控制流的上下文对控制流的 <em>正确</em> 执行的影响。如果在某时刻，由于某种有意或无意的原因，控制流的上下文发生了不是由于控制流本身的指令产生的变化，并使得控制流执行接下来的指令序列时出现了偏差，并最终导致执行过程或执行结果不符合预期，这种情形称为没有正确执行。 所以，我们这里说的控制流的上下文是指仅会影响控制流<strong>正确执行</strong>的有限的物理资源内容。</p>
<p>随着CPU的执行，各种前缀的上下文（执行环境的状态）会在不断的变化。</p>
<p>如果出现了处理器在执行过程中的突变（即异常控制流）或转移（如多层函数调用），需要由维持执行环境的软硬件协同起来，<strong>保存</strong>发生突变或转移前的当前的执行环境的状态（比如突变或函数调用前一刻的指令寄存器，栈寄存器和其他一些通用寄存器等内容），并在完成突变处理或被调用函数后，<strong>恢复</strong>突变或转移前的执行环境的状态。这是由于完成与突变相关的执行会破坏突变前的执行环境状态（比如上述各种寄存器的内容），导致如果不保存状态，就无法恢复到突变前执行环境，继续正常的普通控制流的执行。</p>
<p>对于异常控制流的上下文保存与恢复，主要是通过 CPU 和操作系统（手动编写在栈上保存与恢复寄存器的指令）来协同完成；对于函数转移控制流的上下文保存与恢复，主要是通过编译器（自动生成在栈上保存与恢复寄存器的指令）来帮助完成的。</p>
<p>在操作系统中，需要处理三类异常控制流：<strong>外设中断</strong> (Device Interrupt) 、<strong>陷入</strong> (Trap) 和<strong>异常</strong> (Exception，也称Fault Interrupt)。</p>
<blockquote>
<p>Q: 应用程序也有其上下文吗？</p>
<p>A: 如果一个控制流是属于某个应用程序的，那么这个控制流的上下文简称为应用程序上下文。</p>
</blockquote>
<p>从开始到结束的整个执行过程中，截取其中一个时间段，在这个时间段中，它所执行的指令流形成了这个时间段的控制流，而控制流中的每条执行的指令和它执行后的上下文，形成由二元组&lt;指令指针，上下文&gt;（&lt;pc，context&gt;）构成的有序序列，我们用 <strong>执行流</strong> (Execution Flow) 或 <strong>执行历史</strong> (Execution History) 来表示这个二元组有序序列。</p>
<ul>
<li>外设 <strong>中断</strong> (Interrupt) 由外部设备引起的外部 I&#x2F;O 事件如时钟中断、控制台中断等。外设中断是异步产生的，与处理器的执行无关。</li>
<li><strong>异常</strong> (Exception) 是在处理器执行指令期间检测到不正常的或非法的内部事件（如除零错、地址访问越界）。</li>
<li><strong>陷入</strong> (Trap) 是在程序中使用请求操作系统服务的系统调用而引发的有意事件。</li>
</ul>
<blockquote>
<p>在RISC-V的特权级规范文档中，“陷入” 包含中断和异常，而原来意义上的陷入(trap，系统调用)只是exception中的一种情况。另外还有一种 “软件中断” ，它是指软件可以通过写特定寄存器（mip&#x2F;sip）的特定位（MSIP&#x2F;SSIP&#x2F;USIP）来产生的中断。而异常和中断有严格的区分，在记录产生的异常或中断类型的特定寄存器（mcause&#x2F;scause）中，寄存器最高位为 <code>0</code> 表示异常，最高位为 <code>1</code> 表示中断。进一步的详细信息可以可参考RISC-V的特权级规范文档和后面的章节。</p>
</blockquote>
<h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>为了提高处理器的利用率，操作系统需要让处理器足够忙，即让不同的程序轮流占用处理器来运行。如果一个程序因某个事件而不能运行下去时，就通过进程上下文切换把处理器占用权转交给另一个可运行程序。进程上下文切换如下图所示：</p>
<img src="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/context-switch.png" alt="进程上下文切换" style="zoom:33%;" />

<p>一个进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 操作系统中的进程管理需要采用某种调度策略将处理器资源分配给程序并在适当的时候回收，并且要尽可能充分利用处理器的硬件资源。</p>
<hr>
<p>对于函数调用与物理内存分配得问题，参考<a href="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/chapter1/4understand-prog.html#function-call-and-stack">理解应用程序和执行环境 — rCore-Tutorial-Book-v3 0.1 文档</a></p>
<h5 id="栈指针"><a href="#栈指针" class="headerlink" title="栈指针"></a>栈指针</h5><p><em><strong>寄存器被保存在 栈 (Stack)中</strong></em> ，<code> sp(x2)</code> 常用来保存 <strong>栈指针</strong> (Stack Pointer)，它是一个指向了内存中<strong>已经用过的位置</strong>的一个地址。在 RISC-V 架构中，栈是从高地址到低地址增长的。在一个函数中，作为起始的开场白负责分配一块新的栈空间，其实它只需要知道需要空间的大小，<strong>然后将</strong> <code>sp</code> 的值减小相应的字节数即可，于是物理地址区间<code>[新sp,旧sp)</code> 对应的物理内存便可以被这个函数用来函数调用上下文的保存&#x2F;恢复 以及其他工作，这块物理内存被称为这个函数的 <strong>栈帧</strong> (Stackframe)。</p>
<p>同理，函数中作为结尾的收场白负责将开场白分配的栈帧回收，这也仅仅需要 将 <code>sp</code> 的值增加相同的字节数回到分配之前的状态。这也可以解释为什么 <code>sp</code> 是一个<strong>被调用者保存寄存器</strong>(作为临时寄存器使用，保存后才能在函数中使用)。</p>
<blockquote>
<p>可以理解为手动处理地址之间的变化，实现了一个栈.</p>
</blockquote>
<img src="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/_images/CallStack.png" alt= "栈指针" style="zoom:33%;" />
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
</search>
